{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#start-here","title":"Start here","text":""},{"location":"#important-deprecation-note","title":"\u26a0 Important deprecation note","text":"<p>Current <code>circom</code> is a compiler written in Rust. The old <code>circom</code> compiler written in Javascript will be frozen, but it can still be downloaded from the old circom repository.</p>"},{"location":"#about-the-circom-ecosystem","title":"About the circom ecosystem","text":"<p>The circom compiler and its ecosystem of tools allows you to create, test and create zero knowledge proofs for your circuits.</p>"},{"location":"#circom","title":"circom","text":"<p><code>circom</code> is a compiler written in Rust for compiling circuits written in the <code>circom</code> language. The compiler outputs the representation of the circuit as constraints and everything needed to compute different ZK proofs. </p>"},{"location":"#circomlib","title":"circomlib","text":"<p>With <code>circom</code>, it is possible to create large circuits by combining smaller generic circuits called <code>templates</code>. The <code>circomlib</code> is a library of <code>circom</code> templates that contains hundreds of circuits such as comparators, hash functions, digital signatures, binary and decimal convertors and many more. You can also create your custom templates, but before start coding, we recommend you to take a look at our already created templates.</p> <p>The package already contains tests for circuits available in the <code>circomlib</code>. The package also installs the npm packages <code>circomlibjs</code>, <code>circom_tester</code> and <code>ffjavascript</code> as dependencies.</p>"},{"location":"#circomlibjs","title":"circomlibjs","text":"<p><code>circomlibjs</code> is a Javascript library that provides programs to compute the witness of several circuits of <code>circomlib</code>. This library is used to check that the witness computed  using the wasm or c code generated by <code>circom</code> from many circuits in the <code>circomlib</code> match the ones generated by the corresponding Javascript program in <code>circomlibjs</code>.</p> <p>The package includes these programs in the src directory. In the  test directory it includes its own tests. In the tools directory it includes programs to precompute some needed parameters.</p>"},{"location":"#circom_tester","title":"circom_tester","text":"<p>The <code>circomtester</code> is a npm package that provides tools for testing <code>circom</code> circuits.</p>"},{"location":"#ffjavascript","title":"ffjavascript","text":"<p>The <code>ffjavascript</code> is a npm package with Javascript code to perform finite field operations in Javascript. </p>"},{"location":"#snarkjs","title":"snarkjs","text":"<p><code>snarkjs</code> is a npm package that contains code to generate and validate ZK proofs from the artifacts produced by <code>circom</code>. </p>"},{"location":"#visual-summary","title":"Visual summary","text":""},{"location":"background/background/","title":"Background","text":""},{"location":"background/background/#zero-knowledge-proofs","title":"Zero-knowledge proofs","text":"<p>Recently, a set of cryptographic primitives called zero-knowledge proofs (ZKPs) agitated the world of public blockchains and distributed ledgers. ZKPs came up first as a solution to privacy issues but they have lately also stood up as a perfect solution to scalability issues. As a result, these cryptographic proofs have become very attractive tools to the blockchain community, and the most efficient algorithms have already been deployed and integrated in several applications.</p> <p>A zero-knowledge proof is a protocol that enables one party, called the prover, to convince another, the verifier, that a statement is true without revealing any information beyond the veracity of the statement. For example, a prover can create proofs for statements like the following:</p> <ul> <li>\"I know the private key that corresponds to this public key\" : in this case, the proof would not reveal any information about the private key.</li> <li>\"I know a private key that corresponds to a public key from this list\" : as before, the proof would not reveal information about the private key but in this case, the associated public key would also remain private.</li> <li>\"I know the preimage of this hash value\" : in this case, the proof would show that the prover knows the preimage but it would not reveal any information about the value of that preimage.</li> <li>\"This is the hash of a blockchain block that does not produce negative balances\" : in this case, the proof would not reveal any information about the amount, origin or destination of the transactions included in the block.</li> </ul> <p>Non-interactive zero-knowledge proofs (NIZK) proofs are a particular type of zero-knowledge proofs in which the prover can generate the proof without interaction with the verifier. NIZK protocols are very suitable for Ethereum blockchain applications, because they allow a smart contract to act as a verifier. This way, anyone can generate a proof and send it as part of a transaction to the smart contract, which can perform some action depending on whether the proof is valid or not.</p> <p>In this context, the most preferable NIZK proofs are zk-SNARK proofs (Zero-knowledge Succinct Non Interactive ARgument of Knowledge), a set of non-interactive zero-knowledge protocols that have succinct proof size and sublinear verification time. The importance of these protocols is double: on the one hand, they help improve privacy guarantees, but on the other, their small proof size has been used in scalability solutions.</p>"},{"location":"background/background/#arithmetic-circuits","title":"Arithmetic circuits","text":"<p>Like most ZKPs, zk-SNARKs permit proving computational statements, but they cannot be applied to the computational problem directly, the statement first needs to be converted into the right form. Specifically, zk-SNARKs require the computational statement to be modeled with an arithmetic circuit. Although it may not always be obvious how to do this conversion, most computational problems we care about can easily be converted into arithmetic circuits.</p> <p>An <code>F_p</code>-arithmetic circuit is a circuit consisting of set of wires that carry values from the field <code>F_p</code> and connect them to addition and multiplication gates <code>modulo p</code>.</p> <p>\ud83d\udc49 Remember that given a prime number <code>p</code>, the finite field <code>F_p</code> consists of the set of numbers <code>{0,...,p-1}</code>on which we can add and multiply these numbers modulo <code>p</code>.</p> <p>For example, the finite field <code>F_7</code> consists of the set of numbers <code>{0,...,6}</code>on which we can add and multiply numbers modulo <code>7</code>. An easy way to understand how operating modulo <code>7</code> works, is to think of a clock of 7 hours in which we do not care about how many times the hands have turned the clock, only what time they mark. In other words, we only care about the remainder of dividing by 7. For instance:</p> <ul> <li><code>15 modulo 7 = 1</code>, since <code>15 = 7 + 7 + 1</code></li> <li><code>7 modulo 7 = 0</code></li> <li><code>4*3 modulo 7 = 5</code>, since <code>4*3 = 12 = 7 + 5</code></li> </ul>"},{"location":"background/background/#signals-of-a-circuit","title":"Signals of a circuit","text":"<p>So, an arithmetic circuit takes some input signals that are values between <code>0,...,p-1</code> and performs additions and multiplications between them modulo the prime <code>p</code>. The output of every addition and multiplication gate is considered an intermediate signal, except for the last gate of the circuit, the output of which is the output signal of the circuit.</p> <p>To generate and validate zk-SNARK proofs in Ethereum, we need to work with <code>F_p</code>-arithmetic circuits, taking the prime:</p> <pre><code>p = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n</code></pre> <p>\ud83d\udc49 This prime <code>p</code> is the order of the scalar field of the BN254 curve (also known as the ALT_BN128 curve) as defined in EIP 196. </p> <p>\ud83d\udc49 Circom 2.0.6 introduces two new prime numbers to work with, namely the order of the scalar field of the BLS12-381</p> <pre><code>52435875175126190479447740508185965837690552500527637822603658699938581184513\n</code></pre> <p>and the goldilocks prime <code>18446744069414584321</code>, originally used in Plonky2.</p> <p>In the figure below, we have defined an <code>F_7</code>-arithmetic circuit that performs the operation: <code>out = a*b + c</code>. The circuit has 5 signals: the signals <code>a</code>, <code>b</code> and <code>c</code> are input signals, <code>d</code> is an intermediate signal and the<code>out</code> signal is the output of the circuit.</p> <p></p>"},{"location":"background/background/#_1","title":"\u200b","text":"<p>In order to use zk-SNARK protocols, we need to describe the relation between signals as a system of equations that relate variables with gates. From now on, the equations that describe the circuit will be called constraints, and you can think of them as conditions that signals of that circuit must satisfy.</p>"},{"location":"background/background/#rank-1-constraint-system","title":"Rank-1 constraint system","text":"<p>If we have an arithmetic circuit with signals <code>s_1,...,s_n</code>, then we define a constraint as an equation of the following form:</p> <p><code>(a_1*s_1 + ... + a_n*s_n) * (b_1*s_1 + ... + b_n*s_n) + (c_1*s_1 + ... + c_n*s_n) = 0</code></p> <p>Note that constraints must be quadratic, linear or constant equations, and sometimes, by doing small modifications (like a change of variable or gathering two constraints), it is possible to reduce the number of constraints or variables. In general, circuits will have several constraints (typically, one per multiplicative gate). The set of constraints describing the circuit is called rank-1 constraint system (R1CS):</p> <p><code>(a_11*s_1 + ... + a_1n*s_n)*(b_11*s_1 + ... + b_1n*s_n) + (c_11*s_1 + ... + c_1n*s_n) = 0</code></p> <p><code>(a_21*s_1 + ... + a_2n*s_n)*(b_21*s_1 + ... + b_2n*s_n) + (c_21*s_1 + ... + c_1n*s_n) = 0</code></p> <p><code>(a_31*s_1 + ... + a_3n*s_n)*(b_31*s_1 + ... + b_3n*s_n) + (c_31*s_1 + ... + c_1n*s_n) = 0</code></p> <p><code>...</code></p> <p><code>...</code></p> <p><code>(a_m1*s_1 + ... + a_mn*s_n)*(b_m1*s_1 + ... + b_mn*s_n) + (c_m1*s_1 + ... + c_mn*s_n) = 0</code></p> <p>Remember that operations inside the circuit are performed modulo a certain prime <code>p</code>. So, all equations above are defined <code>modulo p</code>.</p> <p>In the previous example, the R1CS of our circuit consists of the following two equations:</p> <ul> <li><code>d = a*b modulo 7</code></li> <li><code>out = d+c modulo 7</code></li> </ul> <p>In this case, by replacing directly the variable <code>d</code>, we can gather the two equations into a single one:</p> <ul> <li><code>out = a*b + c modulo 7</code></li> </ul> <p>The nice thing about circuits, is that although most zero-knowledge protocols have an inherent complexity that can be overwhelming for many developers, the design of arithmetic circuits is clear and neat.</p> <p>\ud83d\udc49 With <code>circom</code>, you design your own circuits with your own constraints, and the compiler outputs the R1CS representation that you will need for your zero-knowledge proof.</p> <p>Zero-knowledge permits proving circuit satisfiability. What this means is, that you can prove that you know a set of signals that satisfy the circuit, or in other words, that you know a solution to the R1CS. This set of signals is called the witness.</p>"},{"location":"background/background/#witness","title":"Witness","text":"<p>Given a set of inputs, the calculation of the intermediate and output signals is pretty straightforward. So, given any set of inputs, we can always calculate the rest of the signals. So, why should we talk about circuit satisfiability? The key aspect of zero-knowledge proofs is that it allows you to compute these circuits without revealing information about the signals.</p> <p>For instance, imagine that in the previous circuit, the input <code>a</code> is a private key and the input <code>b</code> is the corresponding public key. You may be okay with revealing <code>b</code> but you certainly do not want to reveal <code>a</code>. If we define <code>a</code> as a private input, <code>b</code>, <code>c</code> as public inputs and <code>out</code> as a public output, with zero-knowledge we are able to prove, without revealing its value, that we know a private input <code>a</code> such that, for certain public values <code>b</code>, <code>c</code> and <code>out</code>, the equation <code>a*b + c = out mod 7</code> holds.</p> <p>Note that we could easily deduce the value of <code>a</code> by isolating it from the other signals. It is important to design circuits that keep the privacy of the private inputs and prevent deducing them from the R1CS.</p> <p>An assignment of the signals is called a witness. For example, <code>{a = 2, b = 6, c = -1, out = 4}</code> would be a valid witness for the circuit. The assignment <code>{a = 1, b = 2, c = 1, out = 0}</code> would not be a valid witness, since it does not satisfy the equation <code>a*b + c = out mod 7</code>.</p>"},{"location":"background/background/#summary","title":"Summary","text":"<p>\u200bIn summary, zk-SNARK proofs are a specific type of zero-knowledge proofs that allow you to prove that you know a set of signals (witness) that match all the constraints of a circuit without revealing any of the signals except the public inputs and the outputs.</p>"},{"location":"circom-language/anonymous-components-and-tuples/","title":"Tuples and Anonymous Components","text":""},{"location":"circom-language/anonymous-components-and-tuples/#anonymous-components","title":"Anonymous Components","text":"<p>circom 2.1.0 introduces a new feature called anonymous component. An anonymous component allows in a single instruction 1) the implicit declaration of a new component, 2) the assignment of every input signal and, finally,  3) the assignment of every output signal.  This section is divided in the next subsections: 1. Syntax and semantics of anonymous components. 2. What if the anonymous component is an instance of a template with more than an output signal?    We introduce the tuples in circom. 3. What if the anonymous component is an instance of a template which input/output signals are arrays?    We introduce the element-wise assignment for signal arrays. 4. What if we are not interested in collecting one of the outputs? We introduce the use of \"_\" to indicate that a signal is not relevant.</p>"},{"location":"circom-language/anonymous-components-and-tuples/#syntax-and-semantics-of-anonymous-components","title":"Syntax and semantics of anonymous components","text":"<p>Let us see a typical circom program. </p> <pre><code>template A(n){\n   signal input a, b;\n   signal output c;\n   c &lt;== a*b;\n}\ntemplate B(n){\n   signal input in[n];\n   signal out;\n   component temp_a = A(n);\n   temp_a.a &lt;== in[0]; \n   temp_a.b &lt;== in[1];\n   out &lt;== temp_a.c;\n}\ncomponent main = B(2);\n</code></pre> <p>Thanks to anonymous components, we can make the above program much cleaner.</p> <pre><code>template A(n){\n   signal input a, b;\n   signal output c;\n   c &lt;== a*b;\n}\ntemplate B(n){\n   signal input in[n];\n   signal out &lt;== A(n)(in[0],in[1]);\n}\ncomponent main = B(2);\n</code></pre> <p>It is important to highlight that both circuits are equivalent: they have the same witnesses and the same constraint, that is, <code>out === in[0]*in[1]</code>.</p> <p>The anonymous components are a new kind of circom expression whose syntax is as follows: <code>temp_name(arg1,...,argN)(input1,...,inputM)</code>  assuming that we have a template temp_name with N arguments and M input signals. </p> <p>Let us clarify two points: 1. <code>arg1</code>, ..., <code>argN</code> are template arguments. We can use them as usual. They can be arithmetic operations expressions or constants. The important thing is its value must be known at compilation time.  2. <code>input1</code>, ..., <code>inputM</code> are input signals. We can pass another signals, (just like in the example) constants or other anonymous components (in a compositional way), if and only if, such components only have 1 output signal.</p> <p>The order of the signals in the anonymous component matters: the ith input signal receives the value of the ith signal passed as parameter. Since circom 2.1.1, it is also allowed to indicate the name of the input signal corresponding to each parameter, followed by <code>&lt;==</code> and then the expression in R1CS format). In that case, we can uses any order in giving the inputs provided all the subcomponent inputs are given. Note that either we use the notation with <code>&lt;==</code> for all inputs or none. Let us see this new feature in the previous example:</p> <pre><code>template A(n){\n   signal input a, b;\n   signal output c;\n   c &lt;== a*b;\n}\ntemplate B(n){\n   signal input in[n];\n   signal out &lt;== A(n)(b &lt;== in[1], a &lt;== in[0]);\n}\ncomponent main = B(2);\n</code></pre> <p>The value returned by the anonymous components depends on the number of template's output signals.</p> <ol> <li> <p>If the template does not define any output signal (for instance, if it only defines constraints based on the input signals),  we can use the anonymous component like if it was a statement     <code>temp_name(arg1,...,argN)(inp1,...,inpM);</code></p> </li> <li> <p>If the template defines a single output signal, we can use any of the well-known operators to collect the output signal. It is important to highlight that we can use with the anonymous components any of the operators <code>&lt;==</code>, <code>==&gt;</code> and <code>=</code>  with the usual semantics, but not <code>&lt;--</code> and <code>--&gt;</code>, since there is no way to add additional constraints including the signals of the anonymous components (which will end up in security issues in most of the cases). For instance, <code>signal out &lt;== temp_name(a1,...,aN)(i1,...,iM);</code></p> </li> <li> <p>If the template defines more than an output signal, we need to use a new kind of expression to collect all the outputs: the tuples, whose syntax is the usual in other programming languages.</p> </li> </ol> <pre><code>signal output o1, ..., oK;\n(o1,...,oK) &lt;== temp_name(a1,...,aN)(i1,...,iM);\n</code></pre> <pre><code>var  v1, ..., vK;\n(v1,...,vK) = temp_name(a1,...,aN)(i1,...,iM);\n</code></pre>"},{"location":"circom-language/anonymous-components-and-tuples/#the-use-of-tuples","title":"The use of tuples","text":"<p>Tuples are a typical expression in other programming languages, which allows us to do multiple assignments like in the previous example.</p> <p>We have introduced tuples because of the previous feature. When using templates with several outputs is necessary being able to collect all the outputs at the same time, since the component is anonymous and later cannot be accessed.</p> <p>Apart from the main use of the tuples, we can use this new kind of expressions with every kind of assignment  <code>&lt;==</code>,<code>=</code> and <code>&lt;--</code>. However, the latter is not allowed when getting the result of an anonymous component and its use is in general discouraged. Tuples can only be used in combination of any of these operators whenever there are tuples in both sides of the statement. In this case, the semantics of this multiple assignment is the element-wise assignment. </p> <p>Let us see a non-trivial example to illustrate the importance of the order of the tuple elements.</p> <pre><code>var a = 0, b = 0; component c;\n(a, b, c) = (1,a+1, A(2));\n</code></pre> <p>This is internally translated by the compiler to</p> <pre><code>a = 1; \nb = a + 1; \nc = A(2);\n</code></pre> <p>Then, the final value of a and b is 1 and 2, respectively. Notice that c is an instance of template A and we could use now statements to access its inputs and outputs.</p>"},{"location":"circom-language/anonymous-components-and-tuples/#the-use-of-for-signal-arrays","title":"The use of &lt;== for signal arrays","text":"<p>One more extension must be added to circom in order to enable the use of anonymous components. </p> <p>How could we use a template as anonymous component if it makes use of input/output signal arrays? So far, this could not be handled by circom. </p> <p>In circom 2.1.0, we have overloaded the operator <code>&lt;==</code> for signal arrays with the same dimension to express the element-wise assignment. For instance, let us consider the next code.</p> <pre><code>template Ex(n,m){ \n   signal input in[n];\n   signal output out[m];\n   out &lt;== in;\n}\n</code></pre> <p>If <code>n != m</code>, then the compiler reports an error, since both arrays have not the same size. Otherwise, the code is equivalent to:</p> <pre><code>template Ex(n, m){ \n   signal input in[n];\n   signal output out[m];\n   var i = 0;\n   while(i &lt; n) { \n      out[i] &lt;== in[i];\n      i += 1;\n   }\n}\n</code></pre> <p>Let us use this template to illustrate how this new feature is combined with the use of an anonymous component. </p> <pre><code>template A{\n   signal input i[4];\n   signal output o[4];\n   o &lt;== Ex(4,4)(i);\n}\n</code></pre> <p>Here, we can see that we pass as first signal parameter a 4-size array. Notice that previously we can only write a program similar to:</p> <pre><code>template A{\n   signal input i[4];\n   signal output o[4];\n   component anon = Ex(4,4);\n   var i = 0;\n   while(i &lt; 4){ \n      anon.in[i] &lt;== i[i];\n      i += 1;\n   }\n   i = 0;\n   while(i &lt; 4){\n      o[i] &lt;== anon.out[i];\n      i += 1;\n   }\n}\n</code></pre>"},{"location":"circom-language/anonymous-components-and-tuples/#the-use-of-_","title":"The use of _","text":"<p>The underscore \"_\" allows to ignore any amount of output signals of the anonymous components. </p> <pre><code>template A(n){\n   signal input a, b, c;\n   signal output d;\n   d &lt;== a*b+c;\n   a * b === c;\n}\ntemplate B(n){\n   signal input in[n];\n   _ &lt;== A(n)(in[0],in[1],in[2]);\n}\ncomponent main = B(3);\n</code></pre> <p>In the previous example, we are interested in adding the constraint  <code>a * b = c</code> to the R1CS, but we can ignore the output signal <code>d</code>. </p> <p>In case the anonymous component has one more than one output, we can ignore the ones we are not interested. </p> <pre><code>template A(n){\n   signal input a;\n   signal output b, c, d;\n   b &lt;== a * a;\n   c &lt;== a + 2;\n   d &lt;== a * a + 2;\n}\ntemplate B(n){\n   signal input in;\n   signal output out1;\n   (_,out1,_) &lt;== A(n)(in);\n}\ncomponent main = B(3);\n</code></pre> <p>In this example, we are only interested in <code>out1 = in + 2</code>.</p>"},{"location":"circom-language/basic-operators/","title":"Basic Operators","text":"<p>Circom provides boolean, arithmetic, and bitwise operators. They have the standard semantics but the arithmetic operators applied to numeric values work modulo p. </p> <p>The precedence and association of the operators are like in Rust (defined here).</p> <p>Expressions can be built using the next operators, but the conditional operator <code>?_:_</code> can only occur at the top level. </p>"},{"location":"circom-language/basic-operators/#field-elements","title":"Field Elements","text":"<p>A field element is a value in the domain of Z/pZ, where p is the prime number set by default to </p> <p><code>p = 21888242871839275222246405745257275088548364400416034343698204186575808495617.</code></p> <p>As such, field elements are operated in arithmetic modulo p.</p> <p>The circom language is parametric to this number, and it can be changed without affecting the rest of the language (using <code>GLOBAL_FIELD_P</code>).</p>"},{"location":"circom-language/basic-operators/#conditional-expressions","title":"Conditional expressions","text":"<p>Boolean_condition ? true_value : false_value</p> <pre><code>var z = x&gt;y? x : y;\n</code></pre> <p>This conditional expression is not allowed in a nested form, hence can only be used at the top level.  </p>"},{"location":"circom-language/basic-operators/#boolean-operators","title":"Boolean operators","text":"<p>Next boolean operators are allowed:</p> Operator Example Explanation &amp;&amp; a &amp;&amp; b Boolean operator AND || a || b Boolean operator OR ! ! a Boolean operator NEGATION"},{"location":"circom-language/basic-operators/#relational-operators","title":"Relational operators","text":"<p>The definition of relational operators <code>&lt; , &gt; , &lt;= , &gt;= , == , !=</code>  depends on the mathematical function <code>val(x)</code> which is defined as follows:         </p> <pre><code>       val(z) = z-p  if p/2 +1 &lt;= z &lt; p\n\n       val(z) = z,    otherwise.\n</code></pre> <p>According to this function, the definition of the relational operators is as follows:</p> <pre><code>`x &lt; y` is defined as val(x % p) &lt; val(y % p)\n\n`x &gt; y` is defined as val(x % p) &gt; val(y % p)\n\n`x &lt;= y` is defined as val(x % p) &lt;= val(y % p)\n\n`x &gt;= y` is defined as val(x % p) &gt;= val(y % p)\n</code></pre> <p>where <code>&lt;, &gt;, &lt;=, &gt;=</code> are the comparison of integers.</p>"},{"location":"circom-language/basic-operators/#arithmetic-operators","title":"Arithmetic operators","text":"<p>All arithmetic operations work modulo p. We have the next operators:</p> Operator Example Explanation + a + b Arithmetic addition modulo p - a - b Arithmetic subtraction modulo p * a * b Arithmetic multiplication modulo p ** a ** b Power modulo p / a / b Multiplication by the inverse modulo p \\ a \\ b Quotient of the integer division % a % b Remainder of the integer division <p>There are operators that combine arithmetic operators with a final assignment.</p> Operator Example Explanation += a += b Arithmetic addition modulo p and assignment -= a -= b Arithmetic subtraction modulo p and assignment *= a *= b Arithmetic multiplication modulo p and assignment **= a ** b Power modulo p and assignment /= a /= b Multiplication by the inverse modulo p and assignment \\= a \\= b Quotient of the integer division and assignment %= a %= b Remainder of the integer division and assignment ++ a++ Unit increment. Syntactic sugar for a += 1 -- a-- Unit decrement. Syntactic sugar for a -= 1"},{"location":"circom-language/basic-operators/#bitwise-operators","title":"Bitwise operators","text":"<p>All bitwise operators are performed modulo p.</p> Operator Example Explanation &amp; a &amp; b Bitwise AND | a | b Bitwise OR ~ ~a Complement to the number of bits of the prime number ^ a ^ b Bitwise XOR &gt;&gt; a &gt;&gt; 4 Right shift operator &lt;&lt; a &lt;&lt; 4 Left shift operator <p>The shift operations also work modulo p and are defined as follows (assuming p&gt;=7). </p> <p>For all <code>k</code> with <code>0=&lt; k &lt;= p/2</code> (integer division) we have that </p> <ul> <li><code>x &gt;&gt; k = x/(2**k)</code> </li> <li><code>x &lt;&lt; k = (x*(2**k)~ &amp; ~mask) % p</code> </li> </ul> <p>where b is the number of significant bits of p and mask is <code>2**b - 1</code>.</p> <p>For all <code>k</code> with <code>p/2 +1&lt;= k &lt; p</code> we have that</p> <ul> <li><code>x &gt;&gt; k = x &lt;&lt; (p-k)</code> </li> <li><code>x &lt;&lt; k = x &gt;&gt; (p-k)</code> </li> </ul> <p>note that <code>k</code> is also the negative number <code>k-p</code>.</p> <p>There are operators that combine bitwise operators with a final assignment.</p> Operator Example Explanation &amp;= a &amp;= b Bitwise AND and assignment |= a |= b Bitwise OR and assignment ~= ~=a Complement to the number of bits of the prime number and assignment ^= a ^= b Bitwise XOR and assignment &gt;&gt;= a &gt;&gt;= 4 Right shift operator and assignment &lt;&lt;= a &lt;&lt;= 4 Left shift operator and assignment"},{"location":"circom-language/basic-operators/#examples-using-operators-from-the-circom-library","title":"Examples using operators from the circom library","text":"<p>In the following, there are several examples using combinations of the previous operators.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate IsZero() {\n    signal input in;\n    signal output out;\n    signal inv;\n    inv &lt;-- in!=0 ? 1/in : 0;\n    out &lt;== -in*inv +1;\n    in*out === 0;\n}\n\ncomponent main {public [in]}= IsZero();\n</code></pre> <p>This template checks if the input signal <code>in</code> is <code>0</code>. In case it is, the value of output signal<code>out</code> is <code>1</code>. <code>0</code>, otherwise. Note here that we use the intermediate signal <code>inv</code> to compute the inverse of the value of <code>in</code> or <code>0</code> if it does not exist. If <code>in</code>is 0, then <code>in*inv</code> is 0, and the value of <code>out</code> is <code>1</code>. Otherwise, <code>in*inv</code> is always <code>1</code>, then <code>out</code> is <code>0</code>.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate Num2Bits(n) {\n    signal input in;\n    signal output out[n];\n    var lc1=0;\n    var e2=1;\n    for (var i = 0; i&lt;n; i++) {\n        out[i] &lt;-- (in &gt;&gt; i) &amp; 1;\n        out[i] * (out[i] -1 ) === 0;\n        lc1 += out[i] * e2;\n        e2 = e2+e2;\n    }\n    lc1 === in;\n}\n\ncomponent main {public [in]}= Num2Bits(3);\n</code></pre> <p>This templates returns a n-dimensional array with the value of <code>in</code> in binary. Line 7 uses the right shift <code>&gt;&gt;</code> and operator <code>&amp;</code> to obtain at each iteration the <code>i</code> component of the array. Finally, line 12 adds the constraint <code>lc1 = in</code> to guarantee  that the conversion is well done.</p>"},{"location":"circom-language/buses/","title":"Buses","text":"<p>circom 2.2.0 introduces a new feature called signal buses. </p>"},{"location":"circom-language/buses/#definition","title":"Definition","text":"<p>A bus is a collection of different but related signals grouped under one name. They are similar to structs in programming languages like C++, helping to make the code more organized and easier to manage.</p> <p>Buses can be defined at the same level as templates and can be used as inputs, intermediates or outputs within a template.</p> <pre><code>bus NameBus(param1,...,paramN){\n    //signals, \n    //arrays,\n    //other buses...\n}\n\n</code></pre> <p>In many circuits we have pairs of signals <code>x</code> and <code>y</code>, which represent the two components of a point. With the new bus feature, we can define a <code>Point</code> bus as follows:</p> <pre><code>bus Point(){\n    signal x;\n    signal y;\n}\n</code></pre> <p>This way, it is clear that <code>x</code> and <code>y</code> should be understood as a single point rather than two independent signals. </p> <p>Using buses, we can modify many templates from the circomlib to make them more readable and organized. Let us consider the <code>Edwards2Montgomery</code> template from <code>montgomery.circom</code>:</p> <pre><code>template Edwards2Montgomery () {\n input Point() { edwards_point } in ;\n output Point() { montgomery_point } out ;\n\n out.x &lt;\u2013- (1 + in.y ) / (1 - in.y ) ;\n out.y &lt;\u2013- out.x / in.x ;\n\n out.x * (1 - in.y ) === (1 + in.y ) ;\n out.y * in.x === out.x ;\n }\n</code></pre> <p>Here, we have a template with an input <code>Point</code> <code>in</code> expected to be in Edwards format, and an output <code>Point</code> <code>out</code> in Montgomery format. </p> <p>The power of buses lies in expressing properties about a collection of related signals. For example, the two signals inside the bus <code>in</code> (respectively <code>out</code>) must satisfy the equations for the Edwards curve (respectively the Montgomery curve). Before circom 2.2.0, this could not be expressed using tags in circom.  But now, we can tag each bus with the corresponding expected format. </p> <p>Besides tagging buses defined in a template, we can also tag their different fields. Let us see this feature in the following example:</p> <pre><code>bus Book () {\n    signal {maxvalue} title[50];\n    signal {maxvalue} author[50];\n    signal {maxvalue} sold_copies;\n    signal {maxvalue} year;\n};\n</code></pre> <p>The <code>Book</code> bus has four different fields: signal arrays  <code>title</code> and <code>author</code> whose letters have a maximum value, the number of sold copies <code>sold_copies</code>, and the publication <code>year</code>, which also has a maximum value. Using buses makes your code clearer and more readable. It is easier to understand that a <code>Book</code> bus represents a book with its fields, rather than dealing with individual signals.</p> <pre><code>template BestSeller2024(){\n    input Book() book;\n    output Book() {best_seller2024} best_book;\n    signal check_copies &lt;== LessThan(book.sold_copies.maxvalue)([1000000,book.sold_copies]);\n    check_copies === 1;\n    signal check_2024 &lt;== IsEqual()([book.year,2024]);\n    check_2024 === 1;\n    best_book &lt;== book;\n}\n</code></pre> <p>As mentioned above, tags work at both levels: at the level of the whole bus, expressing that the book is a best-seller in 2024 (it sold more than 1 million copies), and at the level of the bus signals, expressing the different correctness properties about the book's fields.</p>"},{"location":"circom-language/buses/#approaching-a-type-system-via-buses-and-tags","title":"Approaching a Type System via Buses and Tags","text":"<p>The introduction of buses in circom 2.2.0 brings us closer to having a robust type system. By enforcing compatibility rules in the bus assignments and enabling tagging at both the bus and signal level, buses provide a structured way to manage and verify the relationships between different signals. The combined use of buses and tags emulates the advantages of a traditional type system within circom, enhancing code clarity, reducing errors, and improving overall organization.</p> <p>When assigning one bus to another, they both need to be the same type of bus. Otherwise, the compiler reports an error.</p> <pre><code>bus B1(){\n    signal x;\n}\n\nbus B2() {\n    signal x;\n}\n\ntemplate B1toB2(){\n    input B1() b1;\n    output B2() b2;\n    b2 &lt;== b1;\n}\n\n</code></pre> <p>For the previous example, the compiler reports:</p> <pre><code>error[T2059]: Typing error found\n   \u250c\u2500 \"example.circom\":80:5\n   \u2502\n   \u2502     b2 &lt;== b1;\n   \u2502     ^^^^^^^^^ Assignee and assigned types do not match.\n</code></pre> <p>In this case, the transformation from one type to another should be explicitly done as follows: <code>b2.x &lt;== b1.x;</code>.</p> <p>Consider again the <code>BestSeller2024</code> template and a possible instantiation: <code>Book seller &lt;== BestSeller2024()(b);</code> Similar to tags, whenever a template is instantiated, the compiler checks if the type of <code>b</code> is equals to <code>Book</code>. If it is not, an error is reported. The compiler also checks if the bus' fields have the same tags.</p>"},{"location":"circom-language/buses/#buses-inside-buses","title":"Buses inside Buses","text":"<p>We can have buses inside the definition other buses, as long as we do not define buses  recursively. To illustrate this, let us consider now, a new kind of bus, <code>Person</code>, which contains some information about a person:</p> <pre><code>bus Film() {\n    signal title[50];\n    signal director[50];\n    signal year;\n}\n\nbus Date() {\n    signal day;\n    signal month;\n    signal year;\n}\n\nbus Person() {\n    signal name[50];\n    Film() films[10];\n    Date() birthday;\n}\n</code></pre>"},{"location":"circom-language/buses/#parameterized-buses","title":"Parameterized Buses","text":"<p>Buses can have parameters as well. These parameters must be known during compilation  time and can be used to define arrays or other buses inside themselves. </p> <p>Let us generalize the <code>Point</code> bus for a given dimension. </p> <pre><code>bus PointN(dim){\n    signal x[dim];\n}\n</code></pre> <p>Thanks to this definition, we can define other like lines and figures.  </p> <pre><code>bus Line(dim){\n    PointN(dim) start;\n    PointN(dim) end;\n}\n\nbus Figure(num_sides, dim){\n    Line(dim) side[num_sides];\n}\n</code></pre> <p>Notice that the <code>Figure</code> bus is defined by two parameters: the number of sides and the dimension of its points. Using this bus, we can define every kind of figure in a very simple way. For instance:</p> <pre><code>bus Triangle2D(){\n    Figure(3,2) {well_defined} triangle;\n}\n\nbus Square3D(){\n    Figure(4,3) {well_defined} square;\n}\n</code></pre> <p>We define a <code>Triangle2D</code> bus with three lines whose points are 2-dimensional, and a <code>Square3D</code> bus, whose points are 3-dimensional.</p> <pre><code>template well_defined_figure(num_sides, dimension){\n    input Figure(num_sides,dimension) t;\n    output Figure(num_sides,dimension) {well_defined} correct_t;\n    var all_equals = 0;\n    var isequal = 0;\n    for(var i = 0; i &lt; num_sides; i=i+1){\n        for(var j = 0; j &lt; dimension; j=j+1){\n            isequal = IsEqual()([t.side[i].end.x[j],t.side[(i+1)%num_sides].start.x[j]]);\n            all_equals += isequal;\n        }\n    }\n    all_equals === num_sides;\n    correct_t &lt;== t;\n}\n</code></pre> <p>The previous template defines a correctness check for any figure: the ending point of a line must be the starting point of the next line. Otherwise, the figure is not well defined, and the witness generation will fail. </p>"},{"location":"circom-language/buses/#buses-as-circuit-inputs","title":"Buses as Circuit Inputs","text":"<p>Similar to signals, buses can be part of the main circuit's inputs. Therefore, we must specify their values to generate a witness for the circuit. For each circuit input bus, values can be specified in two ways:</p> <ul> <li>Serialized Format: Indicate the value of every signal, bus, or array field in a single array, following the bus's definition order.</li> <li>JSON Format: Provide values using a fully qualified JSON format with field names. Note that you cannot mix both methods within a single bus. If you start defining an input using field names, you must use this method consistently throughout.</li> </ul> <p>Let us consider again the <code>Person</code> bus:</p> <pre><code>bus Film() {\n    signal title[2];\n    signal director[2];\n    signal year;\n}\n\nbus Date() {\n    signal day;\n    signal month;\n    signal year;\n}\n\nbus Person() {\n    signal name[2];\n    Film() films[2];\n    Date() birthday;\n}\n</code></pre> <p>To indicate values for an input <code>p</code> of this kind, we would indicate its values as one of the following ways:</p> <ul> <li>Serialized format:</li> </ul> <pre><code>{\"p\": [\"80\",\"82\",\"20\",\"21\",\"30\",\"31\",\"1953\",\"40\",\"41\",\"50\",\"51\",\"1990\",\"1\",\"1\",\"1992\"]\n}\n</code></pre> <ul> <li>JSON format:</li> </ul> <pre><code>{\"p\": {\"name\": [\"80\",\"82\"],\n       \"films\": [\n            {   \"title\": [\"20\",\"21\"],\n                \"director\": [\"30\",\"31\"],\n                \"year\": \"1953\"\n            },\n            {   \"title\": [\"40\",\"41\"],\n                \"director\": [\"50\",\"51\"],\n                \"year\": \"1990\"\n            }\n        ],\n       \"birthday\":\n            {   \"day\": \"1\",\n                \"month\": \"1\",\n                \"year\": \"1992\"\n            }\n    }\n}\n\n</code></pre> <p>Like public input signals, public input buses cannot be tagged. Otherwise, the compiler will report an error. </p>"},{"location":"circom-language/comment-lines/","title":"Comment Lines","text":"<p>In circom, you can place comments in your source code. These comment lines will be ignored by the compiler.  Comments help programmer reading your source code to better understand it. Adding comments to your code is a highly recommended practice.</p> <p>The comment lines allowed in circom 2.0 are similar to other programming languages like C or C++.</p> <p>You can write comments on a single line by using <code>//</code>:</p> <pre><code>//Using this, we can comment a line.\n</code></pre> <p>You can also write a comment at the end of a code line using <code>//</code>:</p> <pre><code>template example(){\n    signal input in;   //This is an input signal.\n    signal output out; //This is an output signal.\n}\n</code></pre> <p>Finally, you can write comments that span multiple lines using <code>/*</code> and <code>*/</code>:</p> <pre><code>/*\nAll these lines will be \nignored by the compiler.\n*/\n</code></pre>"},{"location":"circom-language/constraint-generation/","title":"Constraint Generation","text":"<p>To understand the constructive part of circom, we need to consider the following type of expressions:</p> <ul> <li>Constant values: only a constant value is allowed.</li> <li>Linear expression: an expression where only addition is used. It can also be written using multiplication of variables by constants. For instance, the expression <code>2*x + 3*y + 2</code> is allowed, as it is equivalent to <code>x + x + y + y + y + 2</code>. </li> <li>Quadratic expression: it is obtained by allowing a multiplication between two linear expressions and addition of a linear expression: A*B - C, where A, B and C are linear expressions. For instance, <code>(2*x + 3*y + 2) * (x+y) + 6*x + y \u2013 2</code>.</li> <li>Non quadratic expressions: any arithmetic expression which is not of the previous kind.</li> </ul> <p>circom allows programmers to define the constraints that define the arithmetic circuit. All constraints must be quadratic of the form A*B + C = 0, where A, B and C are linear combinations of signals. circom will apply some minor transformations on the defined constraints in order to meet the format A*B + C = 0:</p> <ul> <li>Moves from one side of the equality to the other.</li> <li>Applications of commutativity of addition.</li> <li>Multiplication (or division) by constants.</li> </ul> <p>A constraint is imposed with the operator <code>===</code>,  which creates the simplified form of the given equality constraint.</p> <pre><code>a*(a-1) === 0;\n</code></pre> <p>Adding such constraint also implies (by default) adding an <code>assert</code> statement in the witness code generation. Such <code>assert</code> is not added with the compilation option <code>--sanity_check 0</code>.</p> <p>Constraint generation can be combined with signal assignment with the operator  <code>&lt;==</code> with the signal to be assigned on the left hand side of the operator.</p> <pre><code>out &lt;== 1 - a*b;\n</code></pre> <p>Which is equivalent to:</p> <pre><code>out &lt;-- 1 - a*b;\nout === 1 \u2013 a*b;\n</code></pre> <p>As mentioned before, assigning a value to a signal using <code>&lt;--</code> and <code>--&gt;</code> is considered dangerous and should, in general, be combined with adding constraints with <code>===</code>, which describe by means of constraints which the assigned values are. For example:</p> <pre><code>a &lt;-- b/c;\na*c === b;\n</code></pre> <p>In the constructive phase, a variable can contain arithmetic expressions that are built using multiplication, addition, and other variables or signals and field values. Only quadratic expressions are allowed to be included in constraints. Other arithmetic expressions beyond quadratic or using other arithmetic operators like division or power are not allowed as constraints. </p> <pre><code>template multi3() {\n     signal input in;\n     signal input in2;\n     signal input in3;\n     signal output out;\n     out &lt;== in*in2*in3;\n}\n</code></pre> <p>This template produces the error \"Non quadratic constraints are not allowed!\", since it introduces the constraint <code>out === in*in2*in3</code> which is NOT quadratic.</p> <p>The following example shows the generation of expressions:</p> <pre><code> signal input a;\n signal output b;\n var x = a*a;\n x += 3;\n b &lt;== x;\n</code></pre> <p>The last instruction produces the constraint <code>b === a * a + 3</code>.</p> <p>Finally, programmers sometimes misuse operator <code>&lt;--</code>, when starting to work in circom. They usually assign using this operator an expression which is quadratic and, as a consequence, no constraint is added. In this case, the operator needed to both performing the assignment and adding the constraint is operator <code>&lt;==</code>. Since version 2.0.8, we throw a warning in this case. </p>"},{"location":"circom-language/control-flow/","title":"Control Flow","text":"<p>We have standard constructions for defining the control flow of the program.</p>"},{"location":"circom-language/control-flow/#conditional-statement-if-then-else","title":"Conditional statement: if-then-else","text":"<p>if ( boolean_condition ) block_of_code else block_of_code</p> <p>The else part is optional. When omitted, it means \"else do nothing\".</p> <pre><code>var x = 0;\nvar y = 1;\nif (x &gt;= 0) {\n   x = y + 1;\n   y += 1;\n} else {\n   y = x;\n}\n</code></pre>"},{"location":"circom-language/control-flow/#loop-statement-for","title":"Loop statement: for","text":"<p>for ( initialization_code ; boolean_condition ; step_code ) block_of_code</p> <p>If the initialization_code includes a var declaration then its scope is reduced to the for statement and hence, using it later on (without defining it again) will produce a compilation error.</p> <pre><code>var y = 0;\nfor(var i = 0; i &lt; 100; i++){\n    y++;\n}\n</code></pre>"},{"location":"circom-language/control-flow/#loop-statement-while","title":"Loop statement: while","text":"<p>while ( boolean_condition ) block_of_code</p> <p>It executes the block of code while the condition holds. The condition is checked every time before executing the block of code.</p> <pre><code>var y = 0;\nvar i = 0;\nwhile(i &lt; 100){\n    i++;\n    y += y;\n}\n</code></pre> <p>Important: when constraints are generated in any block inside an if-then-else or loop statement, the condition cannot be unknown (see Unknowns). This is because the constraint generation must be unique and cannot depend on unknown input signals.</p> <p>In case the expression in the condition is unknown and some constraint is generated, the compiler will generate the next error message: \"There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase\".</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(){}\ntemplate wrong(N1){\n    signal input in;\n    component c;\n    if(in &gt; N1){\n      c = A();\n    }\n}\ncomponent main {public [in]} = wrong(1);\n</code></pre> <p>In this example, the condition depends on the input signal <code>in</code> whose value is unknown at compilation time.</p> <p>Let us also notice that if the body of the statement does not involve any signal or component; or a constraint does not depend on a value involved with unknown values, then the compilation will succeed as it can be seen in the next example.</p> <pre><code>template right(N){\n    signal input in;\n    var x = 2;\n    var t = 5;\n    if(in &gt; N){\n      t = 2;\n    }\n}\n</code></pre> <p>This template is correct, since no constraint depends on the unknown value of <code>in</code>.</p> <pre><code>template right(N1,N2){\n    signal input in;\n    var x = 2;\n    var t = 5;\n    if(N1 &gt; N2){\n      t = 2;\n    }\n    x === t;\n}\n</code></pre> <p>This template is correct since the values of variables involved in the constraint only depend on known values of parameter <code>N1</code> and <code>N2</code>.</p> <p>Important: Another compilation error is generated when the content of a var depends on some unknown condition: that is when the var takes its value inside an if-then-else or loop statement with an unknown condition. Then, the content of the variable is a non-quadratic expression and, as such, cannot be used in the generation of a constraint.</p> <pre><code>template wrong(){\n    signal input in;\n    var x; \n    var t = 5;\n    if(in &gt; 3){\n      t = 2;\n    }\n    x === t;\n}\n</code></pre> <p>This template produces a compilation error, since the value of variable <code>t</code> involved in the last constraint depends on the unknown value of variable <code>in</code>.</p> <p>The control flow of the computations is like in other imperative languages, but the instantiation of components may not follow the sequential structure of the code because component instantiation will not be triggered until all input signals have a concrete value assigned.</p> <pre><code>template mult(){\n  signal input in[2];\n  signal output out;\n  out &lt;== in[0] * in[1];\n}\n\ntemplate mult4(){\n  signal input in[4];\n  component comp1 = mult();\n  component comp2 = mult();\n  comp1.in[0] = in[0];\n  comp2.in[0] = in[1];\n  comp2.in[1] = in[2];\n  comp1.in[1] = in[3];\n}\n</code></pre> <p>In this example, <code>comp2</code>is instantiated before <code>comp1</code>, since <code>comp2</code>'s input signals have concrete values before <code>comp1</code>'s input signals. Consequently, <code>comp2.out</code> obtains the value after the execution of line 13, whereas <code>comp1.out</code> obtains it after the execution of line 14.</p>"},{"location":"circom-language/custom-templates-snarkjs/","title":"Custom templates in snarkjs","text":"<p>snarkjs provides an implementation of the PLONK's zkSNARK. An extension of the scheme, turbo-PLONK, allows the definition of the so called custom gates: more general transition gates than the ones defined by default for the regular PLONK zkSNARK, that allows the circuit's designer to, maybe, reduce the number of used gates, probably resulting in shorter proofs size or verification times. This document will contain a list of the custom gates implemented in snarkjs that can be used in the circom language. Note that the list may grow over time with the new implementations from the iden3 collaborators or thanks to contributions from the community.</p>"},{"location":"circom-language/custom-templates-snarkjs/#list-of-custom-gates-implemented-in-snarkjs","title":"List of custom gates implemented in snarkjs","text":"<p>At the moment there are no custom gates implemented in snarkjs yet.</p>"},{"location":"circom-language/data-types/","title":"Data types","text":"<p>The basic var types in circom are:</p> <ul> <li>Field element values: integer values modulo the prime number p (see Signals). This is the default type for all signals and basic variables.</li> <li>Arrays: they can hold a finite number of elements (known at compilation time) of the same type (signal, var, or the same type of components or arrays again). The elements are numbered from zero on and can be accessed using the corresponding index of their position. Array access is made using square brackets. Declaration of an array of a given type is made by adding [] aside of the variable identifier and including the size between the brackets (which should be defined using constant values and/or numeric parameters of templates).</li> </ul> <p>The access and the declaration should be consistent with their type and hence we access and declare with m[i][j], since m[i] is an array. Examples of declarations with and without initialization:</p> <pre><code>var x[3] = [2,8,4];\nvar z[n+1];  // where n is a parameter of a template\nvar dbl[16][2] = base;\nvar y[5] = someFunction(n);\n</code></pre> <p>The notation m[i,j] for arrays of arrays (matrices) is not allowed.</p> <p>On the other hand, the following case will produce a compilation error, since the size of the array should be explicitly given;</p> <pre><code>var z = [2,8,4];\n</code></pre> <p>Finally, the type of signals needs to be declared as they cannot be assigned globally as an array. They are assigned by position.</p> <pre><code>  signal input in[3];\n  signal output out[2];\n  signal intermediate[4];\n</code></pre> <p>An array of components must be instantiated with the same template with (optionally) different parameters.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate fun(N){\n  signal output out;\n  out &lt;== N;\n}\n\ntemplate all(N){\n  component c[N];\n  for(var i = 0; i &lt; N; i++){\n     c[i] = fun(i);\n  }\n}\n\ncomponent main = all(5);\n</code></pre> <p>Consequently, the next code will produce the following compilation error: \" c[i] = fun\\(i\\) -&gt; Assignee and assigned types do not match\".</p> <pre><code>pragma circom 2.0.0;\n\ntemplate fun(N){\n  signal output out;\n  out &lt;== N;\n}\n\ntemplate fun2(N){\n  signal output out;\n  out &lt;== N;\n}\n\ntemplate all(N){\n  component c[N];\n  for(var i = 0; i &lt; N; i++){\n        if(i &lt; N)\n             c[i] = fun(i);\n        else\n           c[i] = fun2(i);\n  }\n}\n\ncomponent main = all(5);\n</code></pre> <p>As shown in the previous examples, inline arrays can be used with field elements and signals to assign signal or value arrays. Since Circom 2.2.3, it is also possible to use inline arrays whose elements are buses or anonymous components.</p> <pre><code>bus A(){\n  signal x;\n}\n\ntemplate B(){\n  input A a[3];\n  output A b[3];\n  b &lt;== [a[2], a[0], a[1]];\n}\n</code></pre> <p>Let us see another example of inline arrays, with anonymous components as elements.</p> <pre><code>template checkBinary(){\n  signal input x;\n  signal output {binary} y;\n  y &lt;== x;\n  x * (x-1) === 0; \n}\n\ntemplate needsBinary(){\n  input signal {binary} n[2];\n  output signal m &lt;== n[0] + n[1];\n}\n\ntemplate C(){\n  input signal x[2];\n  output signal y;\n  y &lt;== needsBinary()([checkBinary()(x[0]), checkBinary()(x[1])]);\n}\n</code></pre> <p>In this example, the template <code>needsBinary</code> requires its inputs to be tagged as binary. Therefore, the statement <code>y &lt;== needsBinary()(x)</code> results in a compiler error, since <code>x</code> is not tagged as binary. To fix this, the template <code>checkBinary</code> is used to add the binary tag to each element of the array, making the instantiation of <code>needsBinary</code> correct.</p>"},{"location":"circom-language/functions/","title":"Functions","text":"<p>In circom, functions define generic abstract pieces of code that can perform some computations to obtain a value or an expression to be returned.</p> <pre><code>function funid ( param1, ... , paramn ) {\n\n .....\n\n return x;\n}\n</code></pre> <p>Functions compute numeric (or arrays of) values or expressions. Functions can be recursive. Consider the next function from the circom library.</p> <pre><code>/*\n    This function calculates the number of extra bits \n    in the output to do the full sum.\n */\n\nfunction nbits(a) {\n    var n = 1;\n    var r = 0;\n    while (n-1&lt;a) {\n        r++;\n        n *= 2;\n    }\n    return r;\n}\n</code></pre> <p>Functions cannot declare signals or generate constraints (use templates if you need so). The next function produces the error message: \"Template operator found\".</p> <pre><code>function nbits(a) {\n    signal input in; //This is not allowed.\n    var n = 1;\n    var r = 0;\n    while (n-1&lt;a) {\n        r++;\n        n *= 2;\n    }\n    r === a; //This is also not allowed.\n    return r;\n}\n</code></pre> <p>As usual, there can be many return statements, but every execution trace must end in a return statement (otherwise, a compile error will be produced). The execution of the return statement returns the control to the caller of the function. </p> <pre><code>function example(N){\n     if(N &gt;= 0){ return 1;}\n//   else{ return 0;}\n}\n</code></pre> <p>The compilation of function <code>example</code> produces the next error message: \"In example there are paths without return\".</p>"},{"location":"circom-language/identifiers/","title":"Identifiers","text":"<p>Any non-reserved keyword that starts with any number of \"_\" followed by an ASCII alphabetic character and followed by any number of alphabetic or numeric chars, \"_\" or \"$\" can be used as identifier. Examples of identifiers are the following:</p> <pre><code>signal input _in; \nvar o_u_t;\nvar o$o;\n\n</code></pre>"},{"location":"circom-language/include/","title":"Include","text":"<p>Templates, like other code, can be found in other files like in libraries. In order to use code in other files, we have to include them in our program by using the keyword include, with the corresponding name of the file (.circom extension is the default).</p> <pre><code>include \"montgomery.circom\";\ninclude \"mux3.circom\";\ninclude \"babyjub.circom\";\n</code></pre> <p>This piece of code includes the files <code>montgomery.circom</code>, <code>mux3.circom</code> and <code>babyjub.circom</code> from the circom library.</p> <p>Since circom 2.0.8, option <code>-l</code> is available to indicate the paths where searching the files to be included. </p>"},{"location":"circom-language/pragma/","title":"Pragma","text":""},{"location":"circom-language/pragma/#version-pragma","title":"Version pragma","text":"<p>All files with .circom extension should start with a first <code>pragma</code> instruction specifying the compiler version, like this: </p> <pre><code>pragma circom xx.yy.zz;\n</code></pre> <p>This is to ensure that the circuit is compatible with the compiler version indicated after the <code>pragma</code> instruction. Otherwise, the compiler throws a warning.</p> <p>If a file does not contain this instruction, it is assumed that the code is compatible with the latest compiler's version and a warning is thrown.</p>"},{"location":"circom-language/pragma/#custom-templates-pragma","title":"Custom templates pragma","text":"<p>Since circom 2.0.6, the language allows the definition of custom templates (see this for more information). This <code>pragma</code> allows the circom programmer to easily tell if it's using custom templates: if any file declaring a custom template or including a file declaring any custom template doesn't use this <code>pragma</code>, the compiler will produce an error. Moreover, it will inform the programmer about which files should include this pragma.</p> <p>To use it simply add the following instruction at the beginning (and after the version <code>pragma</code>) of the .circom files that needs it:</p> <pre><code>pragma custom_templates;\n</code></pre>"},{"location":"circom-language/reserved-keywords/","title":"Reserved Keywords","text":"<p>The list of reserved keywords is the following:</p> <ul> <li>signal: Declare a new signal.</li> <li>input: Declare the signal as input.</li> <li>output: Declare the signal as output.</li> <li>public: Declare the signal as public.</li> <li>template: Define a new circuit.</li> <li>component: Instantiate a template.</li> <li>var: Declare a new integer variable.</li> <li>function: Define a new function.</li> <li>return: Return from function.</li> <li>if: Branch based on the result of a conditional expression.</li> <li>else: Fallback for <code>if</code> control flow construct.</li> <li>for: Loop conditionally based on the result of an expression.</li> <li>while: Loop conditionally based on the result of an expression.</li> <li>do: Loop conditionally based on the result of an expression.</li> <li>log: Print the result of the evaluation.</li> <li>assert: Check the condition at construction time.</li> <li>include: Include code of the indicated file.</li> <li>parallel: To generate C code with the parallel component or template.</li> <li>pragma circom: Instruction to check the compiler version.</li> <li>pragma custom_templates: Instruction to indicate the usage of custom templates.</li> <li>bus: Definition of a bus of signals.</li> </ul>"},{"location":"circom-language/scoping/","title":"Scoping","text":"<p>Circom has static scoping like C and Rust. However, we have that signals, buses and components must have global scoping and hence they should be defined at the top-level block of the template that defines them or, since circom 2.1.5, inside (nested) <code>if</code> blocks, but only if conditions are known at compilation time. </p> <pre><code>pragma circom 2.1.5;\n\ntemplate Cubes (N) {\n   //Declaration of signals.\n   signal input in[N];\n   signal output out[N];\n\n   //Statements.\n   for (var i = 0; i &lt; N; i++) {\n      signal aux;\n      aux &lt;== in[i]*in[i];\n      out[i] &lt;== aux*in[i];      \n   }\n}\n\ncomponent main = Cubes(5);\n</code></pre> <p>Signal <code>aux</code> cannot be declared in the block of the <code>for</code> instruction. The next compilation error is produced: \"<code>aux</code> Is outside the initial scope\".</p> <p>Instead the following program compiles correctly.</p> <pre><code>pragma circom 2.1.5;\ntemplate A(n){\n   signal input in;\n   signal output outA;\n   var i = 0;\n   if(i &lt; n){\n    signal out &lt;== 2;\n    i = out;\n   } \n   outA &lt;== i;\n}\ncomponent main = A(5);\n</code></pre> <p>since the condition <code>i &lt; n</code> is known at compilation time, and then the declaration of signal <code>out</code> is allowed. However, if the condition was <code>in &lt; n</code>, since it is not known at compilation time, it would output an error message because the declaration in that case is not allowed. </p> <p>In any case, we apply a static scoping like in C++ or Rust, and a signal declared inside an <code>if</code> block is only visible inside the block it is declared.</p> <p>Regarding visibility of signals of subcomponent, a signal <code>x</code> of component <code>c</code> is also visible in the template <code>t</code> that has declared <code>c</code>, using the notation <code>c.x</code>, if <code>x</code> is an input or and output of <code>c</code>. No access to intermediate signals of sub-components or signals of nested sub-components is allowed. For instance, if <code>c</code> is built using another component <code>d</code>, the signals of <code>d</code> cannot be accessed from <code>t</code>.  This can be seen in the next code:</p> <pre><code>pragma circom 2.0.0;\n\ntemplate d(){\n  signal output x;\n  x &lt;== 1;\n}\n\ntemplate c(){\n  signal output out2;\n  out2 &lt;== 2;\n  component comp2 = d();\n}\n\ntemplate t(){\n  signal out;\n  component c3 = c();\n  out &lt;== c3.comp2.x;\n}\n\ncomponent main = t();\n</code></pre> <p>That raises an error on <code>c3.comp2.x</code>: \"Signal not found in component: only accesses to input/output signals are allowed\".</p> <p>A var can be defined at any block and its visibility is reduced to the block like in C or Rust.</p>"},{"location":"circom-language/signals/","title":"Signals &amp; Variables","text":"<p>The arithmetic circuits built using circom operate on signals, which contain field elements in Z/pZ. Signals can be named with an identifier or can be stored in arrays and declared using the keyword signal. Signals can be defined as input or output, and are considered intermediate signals otherwise. </p> <pre><code>signal input in;\nsignal output out[N];\nsignal inter;\n</code></pre> <p>This small example declares an input signal with identifier <code>in</code>, an N-dimension array of output signals with identifier <code>out</code> and an intermediate signal with identifier <code>inter</code>.</p>"},{"location":"circom-language/signals/#types-of-signal-assignments","title":"Types of Signal Assignments","text":"<p>Signals can only be assigned using the operations <code>&lt;--</code> or <code>&lt;==</code> (with the signal to be assigned occurring on the left hand side operation) and <code>--&gt;</code> or <code>==&gt;</code> (with the signal to be assigned occurring on the right hand side). All these operations are translated into an assignment in the witness generation code produced by the compiler. However, the key difference between the 'double arrow' assignments <code>&lt;==</code> and <code>==&gt;</code> and the 'single arrow' assignments <code>&lt;--</code> and <code>--&gt;</code> is that only the former adds a constraint to the R1CS system stating that the signal is equal to the assigned expression. Hence, using <code>&lt;--</code> and <code>--&gt;</code> is considered dangerous and strongly discouraged for non expert circom programmers, as it is the most common source of programming buggy ZK-protocols using circom.</p> <p>The safe options for assignments are <code>&lt;==</code> and <code>==&gt;</code>, since the assigned value is the only solution to the constraint system. Using <code>&lt;--</code> and <code>--&gt;</code> should be avoided, and only used when the assigned expression cannot be included in an arithmetic constraint in R1CS, like in the following example.</p> <pre><code>out[k] &lt;-- (in &gt;&gt; k) &amp; 1;\n</code></pre> <p>In such case, since <code>&lt;--</code> and <code>--&gt;</code> do not add any constraint to the R1CS system stating the relation between the signal and the assigned expression, it is crucial to add other constraints expressing such relation. To this end, circom allows to add constraints to the system using the operation <code>===</code>, whose use is explained in more detailed here. </p>"},{"location":"circom-language/signals/#public-and-private-signals","title":"Public and Private Signals","text":"<p>Signals are always considered private. The programmer can distinguish between public and private signals only when defining the main component, by providing the list of public input signals. </p> <pre><code>pragma circom 2.0.0;\n\ntemplate Multiplier2(){\n   //Declaration of signals\n   signal input in1;\n   signal input in2;\n   signal output out;\n   out &lt;== in1 * in2;\n}\n\ncomponent main {public [in1,in2]} = Multiplier2();\n</code></pre> <p>Since circom 2.0.4, it is also allowed to initialize intermediate and output signals right after their declaration. Then, the previous example can be rewritten as follows:</p> <pre><code>pragma circom 2.0.0;\n\ntemplate Multiplier2(){\n   //Declaration of signals\n   signal input in1;\n   signal input in2;\n   signal output out &lt;== in1 * in2;\n}\n\ncomponent main {public [in1,in2]} = Multiplier2();\n</code></pre> <p>This example declares input signals <code>in1</code> and <code>in2</code> of the main component as public signals.</p> <p>In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of the signals are all private and cannot be made public. </p> <p>Thus, from the programmer's point of view, only public input and output signals are visible from outside the circuit, and hence no intermediate signal can be accessed.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(){\n   signal input in;\n   signal outA; //We do not declare it as output.\n   outA &lt;== in;\n}\n\ntemplate B(){\n   //Declaration of signals\n   signal output out;\n   component comp = A();\n   out &lt;== comp.outA;\n}\n\ncomponent main = B();\n</code></pre> <p>This code produces a compilation error since signal <code>outA</code> is not declared as an output signal, then it cannot be accessed and assigned to signal <code>out</code>.</p> <p>Signals are immutable, which means that once they have a value assigned, this value cannot be changed any more. Hence, if a signal is assigned twice, a compilation error is generated. This can be seen in the next example where signal <code>out</code> is assigned twice, producing a compilation error.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(){\n   signal input in;\n   signal output outA; \n   outA &lt;== in;\n}\n\ntemplate B(){\n   //Declaration of signals\n   signal output out;\n   out &lt;== 0;\n   component comp = A();\n   comp.in &lt;== 0;\n   out &lt;== comp.outA;\n}\n\ncomponent main = B();\n</code></pre> <p>At compilation time, the content of a signal is always considered unknown (see Unknowns), even if a constant is already assigned to them. The reason for that is to provide a precise \\(decidable\\) definition of which constructions are allowed and which are not, without depending on the power of the compiler to detect whether a signal has always a constant value or not. </p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(){\n   signal input in;\n   signal output outA; \n   var i = 0; var out = 0;\n   while (i &lt; in){\n    out++; i++;\n   }\n   outA &lt;== out;\n}\n\ntemplate B(){\n component a = A();\n a.in &lt;== 3;\n}\n\ncomponent main = B();\n</code></pre> <p>This example produces a compilation error since the value of signal <code>outA</code> depends on the value of signal <code>in</code>, even though such a value is the constant 3.</p> <p>Signals can only be assigned using the operations <code>&lt;--</code> or <code>&lt;==</code> (see Basic operators) with the signal on the left hand side and <code>--&gt;</code> or <code>==&gt;</code> (see Basic operators) with the signal on the right hand side. The safe options are <code>&lt;==</code> and <code>==&gt;</code>, since they assign values and also generate constraints at the same time. Using <code>&lt;--</code> and <code>--&gt;</code> is, in general, dangerous and should only be used when the assigned expression cannot be included in a constraint, like in the following example.</p> <pre><code>out[k] &lt;-- (in &gt;&gt; k) &amp; 1;\n</code></pre>"},{"location":"circom-language/tags/","title":"Signal Tags","text":"<p>circom 2.1.0 introduces a new feature called signal tags. Tags can be defined during the declaration of any signal in a template. The tag list is indicated between brackets right before the signal name.</p> <pre><code>signal (input/output) {tag_1,...,tag_n} signalname;\n</code></pre> <p>Let us see a first well-known example in the circomlib, where the tag is declared in an input signal:</p> <pre><code>template Bits2Num(n) {\n    signal input {binary} in[n];\n    signal output out;\n    var lc1=0;\n\n    var e2 = 1;\n    for (var i = 0; i&lt;n; i++) {\n        lc1 += in[i] * e2;\n        e2 = e2 + e2;\n    }\n\n    lc1 ==&gt; out;\n}\n\ntemplate A(){\n    ...\n    component b = Bits2Num(10);\n    b.in &lt;== a;\n    ...\n}\n</code></pre> <p>The input array <code>in</code> is declared with the tag <code>binary</code>. This tag means that each signal in the array is always expected to be <code>0</code> or <code>1</code>, in order to compute the corresponding number correctly. </p> <p>Then, whenever the previous template is instantiated, the compiler checks if the array  <code>a</code> assigned to the input array has the tag binary, since <code>in</code> has the tag <code>binary</code> in its declaration. If it does not, an error is reported. Notice that the compiler also checks if both arrays have the same size. </p> <p>It is important to highlight that the compiler never does make any check about the validity of the tags. It is the programmer's responsibility to include the constraints and executable code to guarantee that the intended meaning of each signal is always true.</p> <p>When doing a substitution from a tagged signal to another signal, the tags are always inherited by it (even if it is not declared with it). For instance,</p> <pre><code>template A() {\n    signal input {binary} in;\n    signal intermediate;\n    signal {binary} out;\n    intermediate &lt;== in;\n    out &lt;== intermediate;\n}\n</code></pre> <p>In this example, the intermediate signal inherits the binary tag from in even though it is not declared as binary. Finally, out also receives the tag as expected, since the input is binary.</p> <p>Let us consider another well-known template that the programmer can use to guarantee that the output signal is always binary. </p> <pre><code>template IsZero() {\n    signal input in;\n    signal output {binary} out;\n    signal inv;\n    inv &lt;-- in!=0 ? 1/in : 0;\n    out &lt;== -in*inv +1;\n    in*out === 0;\n}\n</code></pre> <p>To the light of this example, when using tags in intermediate or output signals, the programmer must use components like the previous one or explicitly include the constraints to guarantee the validity of the tags.</p>"},{"location":"circom-language/tags/#tags-with-value","title":"Tags with value","text":"<p>Notice that in the previous template <code>Bits2Num</code>, we can add more information about the output signal <code>out</code>: the maximum number of bits needed to represent it is <code>n</code>. To express this fact, it is necessary that tags can have a value.</p> <p>The value of the tag can be accessed using the notation <code>.</code> at any moment as a part of an arithmetic expression. However, if the tag has not been previously initialized, then the compiler reports an error. </p> <p>The value of the tag can also be modified using the notation <code>.</code>, as long as the corresponding signal has not received any value. Valued tags behave like parameters which means that they can only be assigned to values known at compilation time.</p> <p>Let us modify the previous example to include this tag in the template.</p> <pre><code>template Bits2Num(n) {\n    signal input {binary} in[n];\n    signal output {maxbit} out;\n    var lc1=0;\n\n    var e2 = 1;\n    for (var i = 0; i&lt;n; i++) {\n        lc1 += in[i] * e2;\n        e2 = e2 + e2;\n    }\n    out.maxbit = n;\n    lc1 ==&gt; out;\n}\n</code></pre> <p>On the other hand, the next code is erroneous since the tag value is modified after the output receives its value.</p> <pre><code>template Bits2Num(n) {\n    ...\n    lc1 ==&gt; out;\n    out.maxbit = n;\n}\n</code></pre>"},{"location":"circom-language/tags/#tags-in-signal-arrays","title":"Tags in signal arrays","text":"<p>Every signal in an array has exactly the same tag value. Then, the tag is accessed directly from the array name instead of accessing from a particular signal in the array.  Similarly to the previous erroneous example: if a particular position of the array is modified, then the tag value of the whole array cannot be modified at all.</p> <pre><code>template A(){\n    signal output {max} out[100];\n    out[0] &lt;== 1;\n    out.max = 10;\n}\n</code></pre> <p>The compilation of the previous code throws the next error \"Invalid assignment: tags cannot be assigned to a signal already initialized\", since a position of the array (out[0]) already has a value, then the value of max cannot be modified after the first assignment.</p>"},{"location":"circom-language/tags/#tags-in-buses","title":"Tags in buses","text":"<p>Similar to signals, buses and their fields can also be tagged in their declarations. </p> <pre><code>bus Book {\n    signal {maxvalue} title[50];\n    signal pages;\n    signal {maxvalue} year;\n};\n\nbus Person{\n    signal name[50];\n    Book {old} name;\n}\n</code></pre>"},{"location":"circom-language/templates-and-components/","title":"Templates &amp; Components","text":""},{"location":"circom-language/templates-and-components/#templates","title":"Templates","text":"<p>The mechanism to create generic circuits in Circom is the so-called templates.</p> <p>They are normally parametric on some values that must be instantiated when the template is used. The instantiation of a template is a new circuit object, which can be used to compose other circuits, so as part of larger circuits. Since templates define circuits by instantiation, they have their own signals \\(input, output, etc\\).</p> <pre><code>template tempid ( param_1, ... , param_n ) {\n signal input a;\n signal output b;\n\n .....\n\n}\n</code></pre> <p>Templates cannot include local functions or template definitions.</p> <p>Assigning a value to an input signal inside the same template where it has been defined also generates the error \"Exception caused by invalid assignment\" as can be seen in the next example.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate wrong (N) {\n signal input a;\n signal output b;\n a &lt;== N;\n}\n\ncomponent main = wrong(1);\n</code></pre> <p>The instantiation of a template is made using the keyword component and by providing the necessary parameters.</p> <pre><code>component c = tempid(v1,...,vn);\n</code></pre> <p>The values of the parameters should be known constants at compile time. The next code produces this compilation error message: \"Every component instantiation must be resolved during the constraint generation phase\".</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(N1,N2){\n   signal input in;\n   signal output out; \n   out &lt;== N1 * in * N2;\n}\n\n\ntemplate wrong (N) {\n signal input a;\n signal output b;\n component c = A(a,N); \n}\n\ncomponent main {public [a]} = wrong(1);\n</code></pre>"},{"location":"circom-language/templates-and-components/#components","title":"Components","text":"<p>A component defines an arithmetic circuit and, as such, it receives N input signals and produces M output signals and K intermediate signals. Additionally, it can produce a set of constraints.</p> <p>In order to access the input or output signals of a component, we will use dot notation. No other signals are visible outside the component.</p> <pre><code>c.a &lt;== y*z-1;\nvar x;\nx = c.b;\n</code></pre> <p>The component instantiation will not be triggered until all its input signals are assigned to concrete values. Therefore the instantiation might be delayed and hence the component creation instruction does not imply the execution of the component object, but the creation of the instantiation process that will be completed when all the inputs are set. The output signals of a component can only be used when all inputs are set, otherwise a compiler error is generated. For instance, the following piece of code would result in an error:</p> <pre><code>pragma circom 2.0.0;\n\ntemplate Internal() {\n   signal input in[2];\n   signal output out;\n   out &lt;== in[0]*in[1];\n}\n\ntemplate Main() {\n   signal input in[2];\n   signal output out;\n   component c = Internal ();\n   c.in[0] &lt;== in[0];\n   c.out ==&gt; out;  // c.in[1] is not assigned yet\n   c.in[1] &lt;== in[1];  // this line should be placed before calling c.out\n}\n\ncomponent main = Main();\n</code></pre> <p>Components are immutable (like signals). A component can be declared first and initialized in a second step. If there are several initialization instructions (in different execution paths) they all need to be instantiations of the same template (maybe with different values for the parameters).</p> <pre><code>template A(N){\n   signal input in;\n   signal output out;\n   out &lt;== in;\n}\n\ntemplate C(N){\n   signal output out;\n   out &lt;== N;\n}\ntemplate B(N){\n  signal output out;\n  component a;\n  if(N &gt; 0){\n     a = A(N);\n  }\n  else{\n     a = A(0);\n  }\n  a.in &lt;== 1;\n  a.out ==&gt; out;\n}\n\ncomponent main = B(1);\n</code></pre> <p>If the instruction <code>a = A(0);</code>is replaced with <code>a = C(0)</code>, the compilation fails and the next error message is shown: \"Assignee and assigned types do not match\".</p> <p>We can define arrays of components following the same restrictions on the size given before. Moreover, initialization in the definition of arrays of components is not allowed, and instantiation can only be made component by component, accessing the positions of the array. All components in the array have to be instances of the same template as it can be seen in the next example.</p> <pre><code>template MultiAND(n) {\n    signal input in[n];\n    signal output out;\n    component and;\n    component ands[2];\n    var i;\n    if (n==1) {\n        out &lt;== in[0];\n    } else if (n==2) {\n          and = AND();\n        and.a &lt;== in[0];\n        and.b &lt;== in[1];\n        out &lt;== and.out;\n    } else {\n        and = AND();\n        var n1 = n\\2;\n        var n2 = n-n\\2;\n        ands[0] = MultiAND(n1);\n        ands[1] = MultiAND(n2);\n        for (i=0; i&lt;n1; i++) ands[0].in[i] &lt;== in[i];\n        for (i=0; i&lt;n2; i++) ands[1].in[i] &lt;== in[n1+i];\n        and.a &lt;== ands[0].out;\n        and.b &lt;== ands[1].out;\n        out &lt;== and.out;\n    }\n}\n</code></pre> <p>When components are independent (the inputs do not depend on each others\u2019 outputs), the computation of these parts can be done in parallel using the tag <code>parallel</code>, like shown in the next line.</p> <pre><code>template parallel NameTemplate(...){...}\n</code></pre> <p>If this tag is used, the resulting C++ file will contain the parallelized code to compute the witness. Parallelization becomes particularly relevant when dealing with large circuits.</p> <p>Notice that the previous parallelism is declared at template level. Sometimes, it can be useful declare the parallelism for each component. Since version 2.0.8, the tag parallel can be also used at component level, with the parallel tag indicated right before the call to the template.</p> <pre><code>component comp = parallel NameTemplate(...){...}\n</code></pre> <p>A real example of use case is the following piece of code from the rollup code:</p> <pre><code>component rollupTx[nTx];\nfor (var i = 0; i &lt; nTx; i++) {\n        rollupTx[i] = parallel RollupTx(nLevels, maxFeeTx);\n}\n</code></pre> <p>It is important to highlight again that this parallelism can only be exploited in C++ witness generator.</p>"},{"location":"circom-language/templates-and-components/#custom-templates","title":"Custom templates","text":"<p>Since version 2.0.6, the language allows the definition of a new type of templates, custom templates. This new construction works similarly to standard templates: they are declared analogously, just adding the keyword <code>custom</code> in its declaration after <code>template</code>; and are instantiated in the exact same way. That is, a custom template <code>Example</code> is defined and then instantiated as follows:</p> <pre><code>pragma circom 2.0.6; // note that custom templates are only allowed since version 2.0.6\npragma custom_templates;\n\ntemplate custom Example() {\n   // custom template's code\n}\n\ntemplate UsingExample() {\n   component example = Example(); // instantiation of the custom template\n}\n</code></pre> <p>However, the way in which their computation is encoded is different from the one for standard templates. Instead of producing r1cs constraints, the usage of each defined custom template will be treated in a later stage by snarkjs to generate and validate the zk proof, in this case using the PLONK scheme (and using the custom template's definitions as PLONK's custom gates, see here how). Information about the definition and usages of custom templates will be exported in the <code>.r1cs</code> file (see here sections 4 and 5). This means that custom templates cannot introduce any constraint inside their body, nor declare any subcomponent.</p>"},{"location":"circom-language/templates-and-components/#extern-c-code-in-custom-templates","title":"Extern C code in custom templates","text":"<p>As a new feature, one can add the keyword <code>extern_c</code> to custom templates as in</p> <pre><code>template custom extern_c A() {\n    signal input in;\n    signal output out;\n\n...\n}\n</code></pre> <p>This feature has only an impact when the compilation is used with the flag <code>--c</code> to generate C code as backend. Otherwise, it is ignored.</p> <p>When <code>extern_c</code> is used and the circom program is compiled with <code>--c</code>, the compiler outputs the following information for each <code>extern_c</code>:</p> <pre><code>*** The method void A(FrElement* out ,uint* size_out ,FrElement* in ,uint* size_in ); generated by the custom gate A needs to be implemented ***\n</code></pre> <p>A cpp file (or several) including all the needed functions must be included in the generated <code>name_cpp</code> folder. Then, running <code>make</code> an executable uising these external functions will be generated.</p>"},{"location":"circom-language/the-main-component/","title":"The Main Component","text":"<p>In order to start the execution, an initial component has to be given. By default, the name of this component is \"main\", and hence the component main needs to be instantiated with some template.</p> <p>This is a special initial component needed to create a circuit and it defines the global input and output signals of a circuit. For this reason, compared to the other components, it has a special attribute: the list of public input signals. The syntax of the creation of the main component is:</p> <pre><code>component main {public [signal_list]} = tempid(v1,...,vn);\n</code></pre> <p>where <code>{public [signal_list]}</code> is optional. Any input signal of the template that is not included in the list is considered private.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(){\n    signal input in1;\n    signal input in2;\n    signal output out;\n    out &lt;== in1 * in2;\n}\n\ncomponent main {public [in1]}= A();\n</code></pre> <p>In this example, we have two input signals <code>in1</code> and <code>in2</code>. Let us notice that <code>in1</code> has been declared as a public signal for the circuit, whereas <code>in2</code> is considered a private signal since it does not appear in the list. Finally, output signals are always considered public signals.</p> <p>Only one main component can be defined, not only in the file being compiled but also in any other circom file included in the program. Otherwise, the compilation fails and the next message is shown: \"Multiple main components in the project structure\"</p>"},{"location":"circom-language/variables-and-mutability/","title":"Variables &amp; Mutability","text":"<p>Variables are identifiers that hold non-signal data and are mutable. Variables are declared using the keyword var as in:</p> <pre><code>var x;\n</code></pre> <p>They hold either numerical values of the field or arithmetic expressions when they are used to build constraints (see Constraint Generation). They can be named using a variable identifier or can be stored in arrays.</p> <p>Variable assignment is made using the equal symbol <code>=</code>. Declarations may also include an initialization, as in the following examples:</p> <pre><code>var x;\nx = 234556;\nvar y = 0;\nvar z[3] = [1,2,3];\n</code></pre> <p>An assignment is a statement and does not return any value, hence it cannot be part of an expression, which avoids misleading uses of <code>=</code>. Any use of <code>=</code> inside an expression will lead to a compilation error.</p> <p>The two examples below would result in compilation errors:</p> <pre><code>a = (b = 3) + 2;\n</code></pre> <pre><code>var x;\nif (x = 3) {\n   var y = 0;\n}\n</code></pre>"},{"location":"circom-language/circom-insight/circom-library/","title":"circom Library","text":""},{"location":"circom-language/circom-insight/circom-library/#circomlib","title":"\ud83d\udc49 CircomLib \ud83d\udc48","text":""},{"location":"circom-language/circom-insight/circom-phases/","title":"circom Compiler","text":"<p><code>circom</code> has two compilation phases:</p> <ol> <li>The construction phase, where the constraints are generated. </li> <li>The code generation phase, where the code to compute the witness is generated.</li> </ol> <p>If an error is produced in any of these two phases, circom will finish with an error code greater than 0. Otherwise, if the compiler finish successfully, it finishes returning 0.</p>"},{"location":"circom-language/circom-insight/compiler-messages/","title":"Compiler Messages","text":"<p>The compiler messages are basically of three kinds: hints, warnings and errors.</p>"},{"location":"circom-language/circom-insight/compiler-messages/#a-hint","title":"A hint","text":"<p>This message means that it is allowed but uncommon, and hence it is better to check if it was done on purpose.</p>"},{"location":"circom-language/circom-insight/compiler-messages/#a-warning","title":"A warning","text":"<p>This message means that it is allowed but should not happen in general.</p> <p>For instance, if a signal is not used in any constraint, a warning message will be generated when compiling the circuit with the <code>--inspect</code> option.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(N){\n   signal input in;\n   signal intermediate;\n   signal output out;\n   intermediate &lt;== 1;\n   out &lt;== intermediate;\n}\ncomponent main {public [in]} = A(1);\n</code></pre>"},{"location":"circom-language/circom-insight/compiler-messages/#an-error","title":"An error","text":"<p>This message means that it is not allowed and the compilation of the program fails. For instance, one of the most common errors we can make when starting to program in circom is trying to assign a value to a signal using <code>=</code>.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(){\n  signal in;\n  in = 1;\n}\n\ncomponent main = A();\n</code></pre> <p>The compilation fails and the next error is received: \"Assignee and assigned types do not match operator.\" </p>"},{"location":"circom-language/circom-insight/simplification/","title":"Constraint simplification","text":"<p>Constraint simplification is a key part of the <code>circom</code> compiler. A fast simplification <code>--O1</code> is activated by default (it only applies constant and renaming simplifications), and its associated flag is <code>--O1</code> (see the compilation options). Simplification is not applied when the flag <code>--O0</code> is activated, and a full form of simplification is applied when using the flag <code>--O2</code>.</p> <p>Let us explain the kind of simplification we can perform in detail.</p> <p>As pointed out in Section 2.3 (Quadratic arithmetic programs) of the Groth16 paper (where ZK-SNARKs based on arithmetic circuits were introduced): </p> <p>Addition gates are handled for free in the sums defining the equations, i.e., if a<sub>i</sub> + a<sub>j</sub> = a<sub>k</sub> and a<sub>k</sub> is multiplied by a<sub>l</sub>, we may simply write (a<sub>i</sub> + a<sub>j</sub>) * a<sub>l</sub> and skip the calculation of a<sub>k</sub>.</p> <p>Note that since we can skip its calculation, it will not be part of the witness (the values of the signals that satisfy the arithmetic circuit, i.e. the quadratic constraints).</p> <p>This means that we can remove any constraint E = 0 if E is linear, by choosing one of the signals in E, say x, and expressing E = 0 as x = E' and replacing x by E' in all other constraints. This way, we may skip the calculation of x since it is not in the resulting problem.</p> <p>In the context of [Groth16], the statement to be proved is that given the public inputs and outputs and the relation between them expressed by means of quadratic constrains of the form A*B-C = 0 (where A, B and C are linear expressions) we know a witness (an assignment to the signals that includes the given public inputs and outputs) that satisfies the relation (i.e. the constraints for the given public inputs and outputs). Therefore, we cannot remove the public inputs and outputs (even if they occur in a linear constraint) but we can remove any other private signal if it is equivalent to a linear combination of the other signals (i.e. just using additions), since <code>we can skip the computation of such signal</code> (because <code>addition gates are handled for free</code>) and we are not changing the relation between public inputs and outputs, i.e. the statement.</p> <p>In case we are using the PLONK proof system (instead of Groth16), since additions are not free we cannot remove linear constraints anymore. Still we can remove equalities between signals or equalities between signals and constants which is made with the flag --O1 (see below). Moreover, note that if we apply linear simplification to a constraint system in PLONK format, the resulting constraints will in general not be in PLONK format anymore, and transforming the result back to PLONK format may lead to a worse result than the original. For this reason, when using PLONK, it is always recommended to use the --O1 flag.</p> <p>Once we have explained why removing any private signal (including the private inputs) and applying linear simplification is correct, let us explain what kind of simplification is applied when we enable the flag <code>--O1</code> (which is activated by default) or the flag <code>--O2</code>. Notice that if we do not want to apply any simplification we must use the flag <code>--O0</code>.</p> <ul> <li> <p>Flag <code>--O1</code> removes two kinds of simple constraints: a) <code>signal = K</code>, being K is a constant in \\(F_p\\) and b) <code>signal1 = signal2</code>. In both cases, at least one of the signals must be private, and it is the one that will be replaced by the other side. Note that there are usually many equalities between two signals in constraints defined by circom programs as they are many times used to connect components with their sub components.</p> </li> <li> <p>Flag <code>--O2</code> applies first the same simplification as in <code>--O1</code> and then applies a lazy form of Gaussian elimination to remove as many linear constraints containing at least a private signal as possible. After applying the substitutions discovered by the algorithm, non-linear constraints may have become linear. Thus, the Gauss elimination is applied as many rounds as needed until no more linear constraints containing at least a private signal are found.</p> </li> <li> <p>As a special case, the flag <code>--O2round &lt;simplification_rounds&gt;</code> applies the same simplification as in <code>--O2</code>but it limits the maximum number of rounds applied during the optimization to the number given in <code>&lt;simplification_rounds&gt;</code>.</p> </li> <li> <p>Finally, as said, flag <code>--O0</code> indicates that we do not want to apply any kind of simplification.</p> </li> </ul> <p>Only one of these flags/options can be enabled in the compilation.</p> <p>In case we want to see the simplification applied we can use the flag <code>--simplification_substitution</code> to obtain a json file whose format is described here.</p> <p>Since circom 2.2.0, we have set <code>--O1</code> as the default simplification option. This decision aligns with the growing use of Plonk, as <code>--O2</code> is not compatible with it.</p> <p>Note that, using the full simplification <code>--O2</code> can significantly reduce the number of constraints and signals, which has a positive impact in the time and space needed to compute the proof. However, this is the most time and space consuming phase of the compilation process. Hence, with large circuits, say with millions of constraints, compilation can take a long time (even minutes or hours) and can run in out-of-memory exceptions. In such cases, it is recommended to only use the <code>--O2</code> flag in the final steps of the project development.</p> <p>[Groth16] Jens Groth. \"On the Size of Pairing-Based Non-interactive Arguments\". Advances in Cryptology -- EUROCRYPT 2016, pages 305--326. Springer Berlin Heidelberg, 2016.</p>"},{"location":"circom-language/circom-insight/unknowns/","title":"Unknowns","text":"<p>As expressions accepted during constraint generation can at most be quadratic only, certain checks and conditions are imposed on the use of unknown values at compile time.</p> <p>In circom, constant values and template parameters are always considered known, while signals are always considered unknown.</p> <p>Expressions depending only on knowns are considered knowns, while those depending on some unknowns are considered unknowns.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(n1, n2){ // known\n   signal input in1; // unknown\n   signal input in2; // unknown\n   var x = 0; // known\n   var y = n1; // known\n   var z = in1; // unknown\n}\n\ncomponent main = A(1, 2);\n</code></pre> <p>In the code above, the template parameters <code>n1</code>, <code>n2</code> and the constant value <code>0</code> are considered known. Consequently, the variables <code>x</code> and <code>y</code> are also considered known.</p> <p>Meanwhile, the signals <code>in1</code>, <code>in2</code> are considered unknown. Consequently, the variable <code>z</code> is also considered unknown.</p>"},{"location":"circom-language/circom-insight/unknowns/#array","title":"Array","text":"<p>A constraint with an array access must have a known accessing position.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(n){\n   signal input in;\n   signal output out;\n   var array[n];\n\n   out &lt;== array[in];\n   // Error: Non-quadratic constraint was detected statically, using unknown index will cause the constraint to be non-quadratic\n}\n\ncomponent main = A(10);\n</code></pre> <p>In the code above, an array is defined with a known size of value <code>n</code> (as template parameters are always considered known), while a constraint is set to be dependent on the array element at an unknown position <code>in</code> (as signals are always considered unknown).</p> <p>An array must also be defined with a known size. </p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(){\n   signal input in;\n   var array[in];\n   // Error: The length of every array must known during the constraint generation phase\n}\n\ncomponent main = A();\n</code></pre> <p>In the code above, an array is defined with an unknown size of value <code>in</code> (as signals are always considered unknown).</p>"},{"location":"circom-language/circom-insight/unknowns/#bus","title":"Bus","text":"<p>A bus definition must be parametrized only by known values. </p> <pre><code>pragma circom 2.0.0;\n\nbus b(n){\n  signal array[n];\n}\n\ntemplate A(){\n   signal input in;\n   b(in) out;\n   for(i = 0; i &lt; in; i++){\n      out.array[i] &lt;== i;\n   }\n}\n\ncomponent main = A();\n</code></pre> <p>In the code above, the array inside the bus <code>out</code> is initialized depending on the size of signal <code>in</code>, whose value is unknown at compilation time. Thus, the compiler arises an error: ```` error[T20467]: Typing error found   \u250c\u2500 \"pruebas.circom\":9:4   \u2502 9 \u2502    b(in) out;   \u2502    ^^^^^^^^^ Parameters of a bus must be known during the constraint generation phase</p> <p>previous errors were found```</p>"},{"location":"circom-language/circom-insight/unknowns/#control-flow","title":"Control Flow","text":"<p>If <code>if-else</code> or <code>for-loop</code>blocks have unknown conditions, then the block is considered unknown and no constraint can be generated inside it. Consequently, constraint can only be generated in a control flow with known conditions. </p> <p>Take an if-then statement as an example:</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(){\n   signal input in;\n   signal output out;\n\n   if (in &lt; 0){\n       // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase\n       out &lt;== 0;\n   }\n}\n\ncomponent main = A();\n</code></pre> <p>In the code above, a constraint is defined in an if-then statement with a comparative condition involving an unknown value <code>in</code> (as signals are always considered unknown).</p> <p>Similarly, using a for-loop as an example:</p> <pre><code>pragma circom 2.0.0;\n\ntemplate A(){\n   signal input in;\n   signal output out;\n\n   for (var i = 0; i &lt; in; i++){\n       // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase\n       out &lt;== i;\n   }\n}\n\ncomponent main = A();\n</code></pre> <p>In the code above, a constraint is defined in a for-loop with a counting condition to an unknown value <code>in</code> (as signals are always considered unknown).</p> <p>For additional details, see Control Flow.</p>"},{"location":"circom-language/code-quality/code-assertion/","title":"Code Assertion","text":"<p>assert(bool_expression);</p> <p>This statement introduces conditions to be checked. Here, we distinguish two cases depending on if bool_expression is unknown at compilation time:</p> <ul> <li>If the assert statement depends on a control flow with only known conditions (see Unknowns) and the bool_expression is known (e.g., if it only depends on the value of template parameters or field constants), the assert is evaluated in compilation time. If the result of the evaluation is false, then the compilation fails.  Consider the next piece of code:</li> </ul> <pre><code>template A(n) {\n  signal input in;\n  assert(n&gt;0);\n  in * in === n;\n}\n\ncomponent main = A(0);\n</code></pre> <p>Here, the assert can be evaluated during the compilation and the result of the evaluation is false. Thus, the compilation ends throwing error error[T3001]: False assert reached. If the main component was defined as <code>component main = A(2);</code>, then the compilation correctly finishes. </p> <ul> <li>Otherwise, the compiler adds an assert in the final witness-generation code that must be satisfied during the witness generation. In the next example, if the input <code>in</code> passed as parameter to produce the witness does not satisfy the assert, then the witness will not be generated.</li> </ul> <pre><code>template Translate(n) {\n  signal input in;  \n  assert(in&lt;=254);\n  . . .\n}\n</code></pre> <p>Recall that, when a constraint like <code>in * in === n;</code> is introduced with <code>===</code>, then (by default) an assert is automatically added in the witness generation code. In this case, <code>assert(in * in == n)</code>. Such <code>assert</code> is not added with the option <code>--sanity_check 0</code>.</p>"},{"location":"circom-language/code-quality/debugging-operations/","title":"Debugging Operations","text":"<p>In circom there is an operation that can be used while developing circuits to help the programmer debug (note that there are no input/output operations on the standard input/output channels). To this end, the operation <code>log</code> has as parameter a non-conditional expression (i.e., not including the <code>?</code><code>;_</code> operator). The execution of this instruction prints the result of the evaluation of the expression in the standard error stream. As examples consider:</p> <pre><code>log(135);\nlog(c.b);\nlog(x==y);\n</code></pre> <p>Since circom 2.0.6, operation <code>log</code> admits a list of non-conditional expressions and also strings written in the standard way. For instance:</p> <pre><code>log(\"The expected result is \", 135, \" but the value of a is\", a);\n</code></pre> <p>Finally, this operation admits an empty list of expressions which is equivalent to printing an end-of-line. The next two instructions are equivalent:</p> <pre><code>log(\"\");\nlog();\n</code></pre>"},{"location":"circom-language/code-quality/inspect/","title":"Improving security of circuits by using --inspect option","text":"<p>When using --inspect option, the compiler searches for signals that may be underconstrained. In case it finds some, it throws a warning to let the programmer know which are those potentially underconstrained signals. For instance, the compiler throws a warning when some input or output signal of a subcomponent in a template do not appear in any constraint of the father component. In case this is intended, the programmer can use the underscore notation '_' to inform the compiler that such a situation is as expected. A warning is also shown when a signal is not used in any constraint in the component it belongs to. Let us see several cases where we can find that situation. </p> <p>1) The compiler throws a warning if a signal defined in a template does not appear in any constraint of such template for the given instantiation.</p> <pre><code>template B() {\n  signal input in;\n  signal output out;\n  out &lt;== in + 1;\n}\n\ntemplate A(n) {\n  signal aux;\n  signal out;\n  if(n == 2) {\n    aux &lt;== 2;\n    out &lt;== B()(aux);\n  } else {\n    out &lt;== 5;\n  }\n}\n\ncomponent main = A(3);\n</code></pre> <p>In this example, <code>aux</code> is only used in the <code>if</code> branch. Thus, for the main component (with <code>n = 3</code>) , <code>aux</code> remains unconstrained and the compiler throws a warning:</p> <p><code>warning[CA01]: In template \"A(3)\": Local signal aux does not appear in any constraint</code></p> <p>To avoid the warning, we can add the instruction <code>_ &lt;== aux;</code> inside the <code>else</code> branch. This indicates to the compiler that <code>aux</code> is not used in this case.</p> <pre><code>template A(n) {\n  signal aux;\n  signal out;\n  if(n == 2) {\n    aux &lt;== 2;\n    out &lt;== B()(aux);\n  } else {\n    _ &lt;== aux;\n    out &lt;== 5;\n  }\n}\n</code></pre> <p>Alternatively, since <code>circom 2.1.5</code>, we can also define signals inside <code>if</code> blocks with conditions known at compilation time and thus, we can use this feature to solve the previous warning as follows:</p> <pre><code>template A(n) {\n  signal out;\n  if(n == 2) {\n    signal aux &lt;== 2;\n    out &lt;== B()(aux);\n  } else {\n    out &lt;== 5;\n  }\n}\n</code></pre> <ul> <li>Another case where a warning is thrown is when using subcomponents inside a template, since it is required that every input and output signal of each subcomponent in a template should appear in at least one constraint of the father component.</li> </ul> <p>Although this is the common case, specially for inputs, there are cases where some of the outputs of the subcomponent are ignored on purpose as the component is only used to check some properties. To illustrate this, let us consider the well-known template <code>Num2Bits(n)</code> from the circomlib. This template receives an input signal and a parameter <code>n</code> which represents a number of bits and returns an output signal array with <code>n</code> elements, the binary representation of the input. </p> <pre><code>include \"bitify.circom\";\n\ntemplate check_bits(n) {\n  signal input in;\n  component check = Num2Bits(n);\n  check.in &lt;== in;\n}\n\ncomponent main = check_bits(10);\n</code></pre> <p>It is quite common to use the <code>Num2Bits</code> template just to check if <code>in</code> can be represented with <code>n</code>bits. In this case, the main component checks if the value of <code>in</code> can be represented using 10 bits, and it works as expected. The constraints introduced by the subcomponent <code>check</code> will guarantee that the R1CS system only has a solution if <code>in</code> can be represented with 10 bits, but it does not matter which is the specific representation. However, the compiler throws the next warning:</p> <pre><code>In template \"check_bits(10)\": Array of subcomponent input/output signals check.out contains a total \nof 10 signals that do not appear in any constraint of the father component = For example: check.out[0], check.out[1].\n</code></pre> <p>Since we are not interested in the binary representation, the template does not make use of array signal <code>check.out</code>. Thus, we should add <code>_ &lt;== check.out</code> to inform that the binary representation is irrelevant and avoid the warning.</p> <pre><code>template check_bits(n) {\n  signal input in;\n  component check = Num2Bits(n);\n  check.in &lt;== in;\n  _ &lt;== check.out;\n}\n</code></pre> <p>or even using anonymous components we can write</p> <pre><code>template check_bits(n){\n  signal input in;\n  _ &lt;== Num2Bits(n)(in);\n}\n</code></pre> <p>Notice also here that the <code>--inspect</code> option also shows the parameter of the instance that causes a warning (<code>check_bits(10)</code>). In general, we throw as many warnings as instances with different parameters for each template.</p> <ul> <li>In the previous example, we have seen that none of the positions of array <code>check.out</code> are used, and the warning indicates some of the unused positions. Thus, if some of the positions are used, and others are not, the compiler also notifies some of the unused positions. </li> </ul> <pre><code>include \"bitify.circom\";\n\ntemplate parity(n) {\n  signal input in;\n  signal output out;\n  component check = Num2Bits(n);\n  check.in &lt;== in;\n  out &lt;== check.out[0];\n}\n\ncomponent main = parity(10);\n</code></pre> <p>In this case, we are again using a component <code>Num2Bits(10)</code> to get the binary representation of signal <code>in</code>, but we are only interested in the least-significant bit to know its parity. Then, the warning throws the next warning: </p> <pre><code>In template \"parity(10)\": Array of subcomponent input/output signals check.out contains a total of 9 signals \nthat do not appear in any constraint of the father component. = For example: check.out[1], check.out[2].\n</code></pre> <p>To fix this example, we can either add for loop at the end of the template to indicate those positions that are intendedly not used</p> <pre><code>for (var i = 1; i &lt; n; i++) {\n  _ &lt;== check.out[i];\n}\n</code></pre> <p>or simply add <code>_ &lt;== check.out</code> at the end of the template to let the compiler know that the remaining positions are irrelevant (as this is not going to affect to the use of check.out[0]).</p> <ul> <li>Finally, the <code>--inspect</code> option also searches for assignments with operator <code>&lt;--</code> that can be transformed into assignments with operator <code>&lt;==</code>, which automatically include the corresponding constraint to guarantee the code is correct. A typical scenario of this situation is shown below:</li> </ul> <pre><code>out &lt;-- in / 4;\nout*4 === in;\n</code></pre> <p>Here, many circom programmers avoid the use of <code>&lt;==</code>, since they are using the <code>/</code> operator which in many cases turn the expression in non-quadratic. Then, programmers must add the corresponding constraint using <code>===</code> to guarantee the code is correct. However, it is important to notice that the inverse of 4 is another field element (which is computed by the compiler), and thus, <code>in / 4</code> is a linear expression. Consequently, the previous instructions can be replaced by <code>out &lt;== in / 4</code>. In these cases, the compiler suggests to use <code>&lt;==</code> instead of <code>&lt;--</code>.</p>"},{"location":"circom-language/formats/constraints-json/","title":"R1CS json format","text":"<p>The file contains a dictionary with a single entry \"constraints\" and a list of constraints as value.</p> <pre><code>{\n\"constraints\": [\nconstraint_1,\n...\nconstraint_n\n]\n}\n</code></pre> <p>where every constraint is a list with three elements which are the linear expressions A, B and C that represent the constraint A*B -C = 0.</p> <pre><code>[lin_expr_A,lin_expr_B,lin_expr_C]\n</code></pre> <p>where the linear expression is represented by a dictionary with the signal numbers as strings occurring in the linear expression (with non-zero coefficient) as entries and their coefficients (as string) as values:</p> <pre><code>{ \"sig_num_l1\": \"coef_1\", ... , \"sig_num_lm\": \"coef_m\"}`\n</code></pre> <p>If you also include the <code>--sym</code> flag, in the generated sym file you can see the qualified name in the circom program associated to each signal number, with the signal number 0 always expressing the constant 1. This way we can express any constant by having it as coefficient of the signal 0.</p> <p>Let us consider the following simple circuit in 'basic.circom':</p> <pre><code>pragma circom 2.0.0;\n\ntemplate Internal() {\n   signal input in[2];\n   signal output out;\n   out &lt;== in[0]*in[1];\n}\n\ntemplate Main() {\n   signal input in[2];\n   signal output out;\n   component c = Internal ();\n   c.in[0] &lt;== in[0];\n   c.in[1] &lt;== in[1]+2*in[0]+1;\n   c.out ==&gt; out;\n}\n</code></pre> <p>if we run</p> <pre><code>circom basic.circom --json --wasm \n</code></pre> <p>a file 'basic_contraints.json' is generated and it contains two constraints: </p> <pre><code>{\n\"constraints\": [\n[{\"2\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\"},{\"4\":\"1\"},{\"1\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\"}],\n[{},{},{\"0\":\"1\",\"2\":\"2\",\"3\":\"1\",\"4\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\"}]\n]\n}\n</code></pre> <p>As we can see, only constant and renaming (equalities between signals) simplifications have been applied (since the --O1 simplification is the default).</p> <p>Instead, if we run</p> <pre><code>circom basic.circom --json --wasm --O0\n</code></pre> <p>to indicate that we do not want to apply any simplification the generated file 'basic_constraints.json' contains</p> <pre><code>{\n\"constraints\": [\n[{},{},{\"2\":\"1\",\"5\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\"}],\n[{},{},{\"0\":\"1\",\"2\":\"2\",\"3\":\"1\",\"6\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\"}],\n[{},{},{\"1\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\",\"4\":\"1\"}],\n[{\"5\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\"},{\"6\":\"1\"},{\"4\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\"}]\n]\n}\n</code></pre> <p>Finally, if we run </p> <pre><code>circom basic.circom --json --wasm --O2\n</code></pre> <p>we can see that only one constraint is taken after applying the full simplification:</p> <pre><code>{\n\"constraints\": [\n[{\"2\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\"},{\"0\":\"1\",\"2\":\"2\",\"3\":\"1\"},{\"1\":\"21888242871839275222246405745257275088548364400416034343698204186575808495616\"}]\n]\n}\n</code></pre>"},{"location":"circom-language/formats/simplification-json/","title":"Simplification substitution json format","text":"<p>The file contains a dictionary where the entries are the numbers of the simplified signals as a string and the values are the linear expression that has replaced the signal.</p> <pre><code>{\n\"sig_num_1\": lin_expr_1,\n...\n\"sig_num_n\": lin_expr_n,\n}\n</code></pre> <p>where the linear expression is represented by a dictionary with the signal numbers as strings occurring in the linear expression (with non-zero coefficient) as entries and their coefficients (as string) as values: <code>{ \"sig_num_l1\": \"coef_1\", ... , \"sig_num_lm\": \"coef_m\"}</code></p> <p>All signals occurring in the linear expression are signals that are not removed. Hence, if you also include the <code>--sym</code> flag, in the generated sym file all these signals are associated to a position in the witness list. On the other hand, al signals sig_num_1 ... sig_num_n that appear as entries in the substitution dictionary are associated to -1.</p> <p>Let us consider the following simple circuit in 'simplify.circom':</p> <pre><code>pragma circom 2.0.0;\n\ntemplate Internal() {\n   signal input in[2];\n   signal output out;\n   out &lt;== in[0]*in[1];\n}\n\ntemplate Main() {\n   signal input in[2];\n   signal output out;\n   component c = Internal ();\n   c.in[0] &lt;== in[0];\n   c.in[1] &lt;== in[1]+2*in[0]+1;\n   c.out ==&gt; out;\n}\n</code></pre> <p>if we run</p> <pre><code>circom simplify.circom --r1cs --wasm --simplification_substitution\n</code></pre> <p>a file 'simplify_substitutions.json' is generated that contains</p> <pre><code>{\n\"5\" : {\"2\":\"1\"},\n\"4\" : {\"1\":\"1\"}\n}\n</code></pre> <p>where we can see that two signals have been substituted (since the <code>--O1</code> simplification is the default).</p> <p>Instead, if we run</p> <pre><code>circom simplify.circom --r1cs --wasm --simplification_substitution --O0\n</code></pre> <p>to indicate that we do not want to apply any simplification, the generated file 'simplify_substitutions.json' contains</p> <pre><code>{\n}\n</code></pre> <p>Finally, if we run </p> <pre><code>circom simplify.circom --r1cs --wasm --simplification_substitution --O2\n</code></pre> <p>to indicate that we  want to apply the full form of simplification, the generated file 'simplify_substitutions.json' contains:</p> <pre><code>{\n\"5\" : {\"2\":\"1\"},\n\"4\" : {\"1\":\"1\"},\n\"6\" : {\"0\":\"1\",\"2\":\"2\",\"3\":\"1\"}\n}\n</code></pre>"},{"location":"circom-language/formats/sym/","title":"sym format","text":"<p>The format provides a list of lines, where each line contains the information about a signal of the programmed circom circuit given as</p> <pre><code>#s, #w, #c, name\n</code></pre> <p>where</p> <ul> <li> <p>s: a positive number. It is the unique number starting in 1 (0 is reserved to the signal holding the constant value 1) which is assigned by the circom compiler to each signal in the circuit.</p> </li> <li> <p>w: an integer larger than or equal to -1. It gives either the position in the witness where the signal occurs or -1 if the signal is not public and does not occur in any constraint in the generated R1CS. Note that many signals do not appear in the final R1CS because they have been replaced by a linear combination of other signals that is equivalent to it in the simplification phase. In order to know the substitution applied to a removed signal one can add the flag --simplification_substitution to the circom call and check the generated json file. All witness positions except 0 (which is again reserved to the constant value 1) must occur once in the sym file. The length of the witness coincides with the number of (different) signals occurring in the generated R1CS plus one (for the constant 1).</p> </li> <li> <p>c: a non-negative integer (starting in 0). It is the unique number given by the compiler to the component the signal belongs to.</p> </li> <li> <p>name: is a string containing the qualified name of the signal (including the complete component path).</p> </li> </ul> <p>Let us consider the following simple circuit in 'symbols.circom':</p> <pre><code>pragma circom 2.0.0;\n\ntemplate Internal() {\n   signal input in[2];\n   signal output out;\n   out &lt;== in[0]*in[1];\n}\n\ntemplate Main() {\n   signal input in[2];\n   signal output out;\n   component c = Internal ();\n   c.in[0] &lt;== in[0];\n   c.in[1] &lt;== in[1]+2*in[0]+1;\n   c.out ==&gt; out;\n}\n</code></pre> <p>if we run</p> <pre><code>circom symbols.circom --r1cs --wasm --sym \n</code></pre> <p>a file 'symbols.sym' is generated that contains</p> <pre><code>1,1,1,main.out\n2,2,1,main.in[0]\n3,3,1,main.in[1]\n4,-1,0,main.c.out\n5,-1,0,main.c.in[0]\n6,4,0,main.c.in[1]\n</code></pre> <p>where we can see that two signals have been eliminated (since the <code>--O1</code> simplification is the default).</p> <p>Instead, if we run</p> <pre><code>circom symbols.circom --r1cs --wasm --sym --O0\n</code></pre> <p>to indicate that we do not want to apply any simplification the generated file 'symbols.sym' contains</p> <pre><code>1,1,1,main.out\n2,2,1,main.in[0]\n3,3,1,main.in[1]\n4,4,0,main.c.out\n5,5,0,main.c.in[0]\n6,6,0,main.c.in[1]\n</code></pre> <p>Finally, if we run </p> <pre><code>circom symbols.circom --r1cs --wasm --sym --O2\n</code></pre> <p>to indicate that we  want to apply the full form of simplification, the generated file 'symbols.sym' contains</p> <pre><code>1,1,1,main.out\n2,2,1,main.in[0]\n3,3,1,main.in[1]\n4,-1,0,main.c.out\n5,-1,0,main.c.in[0]\n6,-1,0,main.c.in[1]\n</code></pre>"},{"location":"downloads/downloads/","title":"Downloads","text":"<p>circom Linux binary</p> <p>circom macOS binary</p> <p>circom Windows binary</p>"},{"location":"getting-started/compilation-options/","title":"Complete compilation options","text":"<p>If we use the command <code>circom --help</code>, we can see all the options and flags that we can use during the compilation.</p> <pre><code>USAGE:\n    circom [FLAGS] [OPTIONS] [--] [input]\n\nFLAGS:\n        --r1cs                                 Outputs the constraints in r1cs format\n        --sym                                  Outputs witness in sym format\n        --wasm                                 Compiles the circuit to wasm\n        --json                                 Outputs the constraints in json format\n        --wat                                  Compiles the circuit to wat\n    -c, --c                                    Compiles the circuit to C++\n        --O0                                   No simplification is applied\n        --O1                                   Only applies signal to signal and signal to constant simplification. This\n                                               is the default option\n        --O2                                   Full constraint simplification\n        --verbose                              Shows logs during compilation\n        --inspect                              Does an additional check over the constraints produced\n        --use_old_simplification_heuristics    Applies the old version of the heuristics when performing linear\n                                               simplification\n        --simplification_substitution          Outputs the substitution applied in the simplification phase in json\n                                               format\n        --no_asm                               Does not use asm files in witness generation code in C++\n        --no_init                              Removes initializations to 0 of variables (\"var\") in the witness\n                                               generation code\n    -h, --help                                 Prints help information\n    -V, --version                              Prints version information\n\nOPTIONS:\n    -o, --output &lt;output&gt;                    Path to the directory where the output will be written [default: .]\n    -p, --prime &lt;prime&gt;                      To choose the prime number to use to generate the circuit. Receives the\n                                             name of the curve (bn128, bls12377, bls12381, goldilocks, grumpkin, pallas,\n                                             secq256r1, vesta) [default: bn128]\n    -l &lt;link_libraries&gt;...                   Adds directory to library search path\n        --O2round &lt;simplification_rounds&gt;    Maximum number of rounds of the simplification process\n        --sanity_check &lt;sanity_check&gt;        Selects the level of sanity checks to be included in the witness generation\n                                             code generated. It receives the value 0, 1, or 2. [default: 2]\n\nARGS:\n    &lt;input&gt;    Path to a circuit with a main component [default: ./circuit.circom]\n</code></pre> <p>In the following, we explain these options.</p>"},{"location":"getting-started/compilation-options/#flags-and-options-related-to-the-compilers-output","title":"Flags and options related to the compiler's output","text":"<ul> <li>Flag <code>--r1cs</code> outputs the constraints in binary R1CS format (see the detailed format here).</li> <li>Flag <code>--sym</code> outputs for every signal of the circuit: the unique number given by the compiler, the circom qualified name, the number of the witness signal that contains it and the (unique) number of the component (given by the compiler) it belongs (see the detailed format and examples here).</li> <li>Flag <code>--simplification_substitution</code> outputs the substitutions performed by the --O1 (default) and --O2 constraint simplification options in json format (see the detailed format here).</li> <li>Flag <code>--wasm</code> produces a WebAssembly program that receives the private and public inputs and generates the circuit witness.</li> <li>Flag <code>-c / --c</code> produces a C++ program that receives the private and public inputs and generates the circuit witness.<ul> <li>When flag <code>--no_asm</code> is activated the generated C code does not use asm files, this is a new version that can be used in all architectures</li> </ul> </li> <li>Flag <code>--wat</code> compiles the circuit to wat.</li> <li>Flag <code>--json</code> outputs the R1CS system in JSON format (see the detailed format here).</li> <li>Flag <code>--no_asm</code> (combined with the flag <code>--c</code>) generates C++ code without using asm files. This makes the generated code compatible with any architecture.</li> <li>Flag <code>--no_init</code> avoids the introduction of an initialization to 0 in the wasm and C++ code for every declared <code>var</code> in the circom program.</li> <li>Option <code>-o / --output &lt;output&gt;</code> allows to indicate the path to the directory where the output will be written. By default the path is <code>.</code>. </li> <li>Option <code>--sanity_check</code>  controls the amount of runtime checks inserted into the witness generation code:   0 (no sanity checks are added), 1 (insert assert statements for === instructions), 2 (in addition to level 1, each component verifies that all its subcomponents have been executed with all required inputs set).    By default the option is 2. </li> </ul>"},{"location":"getting-started/compilation-options/#flags-and-options-related-to-the-constraint-generation-process","title":"Flags and options related to the constraint generation process","text":"<ul> <li>Flag <code>--verbose</code> shows logs with known values at compilation time during the constraint generation process. </li> <li>Flag <code>--inspect</code> does an additional check over the R1CS system produced. (see --inspect).</li> <li>Flag <code>--use_old_simplification_heuristics</code> allows to use an old heuristics of the optimization algorithm. However, it is not recommended since the new heuristics has produced better results in practice.</li> </ul>"},{"location":"getting-started/compilation-options/#flags-and-options-related-to-the-r1cs-optimization","title":"Flags and options related to the R1CS optimization","text":"<p>In the following, we explain the different optimizations that we can apply to the final R1CS during the constraint generation phase. More details on the simplification process can be found here</p> <ul> <li> <p>Flag <code>--O0</code> does not apply any kind of simplification.</p> </li> <li> <p>Flag <code>--O1</code> removes two kinds of simple constraints: a) <code>signal = K</code>, being K is a constant in \\(F_p\\) and b) <code>signal1 = signal2</code>, which usually appears when linking components inputs and outputs. </p> </li> <li> <p>Flag <code>--O2</code> applies Gauss elimination to remove as many linear constraints as possible. After applying the substitutions discovered by the algorithm, non-linear constraints may become linear. Thus, the Gauss elimination is applied during several rounds until no more linear constraints are discovered.</p> </li> <li> <p>Option <code>--O2round &lt;simplification_rounds&gt;</code> is similar to <code>--O2</code>but it limits the maximum number of rounds applied during the optimization. In <code>&lt;simplification_rounds&gt;</code>, user needs to indicate the number of rounds. </p> </li> </ul> <p>Only one of these flags/options must be used during the compilation.</p>"},{"location":"getting-started/compilation-options/#other-flags-and-options","title":"Other flags and options","text":"<ul> <li> <p>Option <code>-p, --prime &lt;prime&gt;</code> allows the user indicate which prime must be used during the compilation. Currently, it admits six different primes: bn128, bls12377, bls12381, goldilocks, grumpkin, pallas, secq256r1 and vesta. If not indicated, the default prime is bn128.</p> </li> <li> <p>Option <code>-l &lt;link_libraries&gt;</code> adds the provided directory in <code>&lt;link_libraries&gt;</code>to the library search path. It is possible to add as much <code>-l &lt;link_libraries&gt;</code> as needed, but only one directory per option.</p> </li> <li> <p>Flag <code>--no_init</code> removes variable initializations to 0. </p> </li> <li> <p>Flag <code>-v / --version</code> prints the version information.</p> </li> <li>Flag <code>-h / --help</code> prints the help information.</li> </ul>"},{"location":"getting-started/compiling-circuits/","title":"Compiling our circuit","text":"<p>Once you have the compiler installed you can see the available options as follows:</p> <pre><code>circom --help\n\nUSAGE:\n    circom [FLAGS] [OPTIONS] [--] [input]\n\nFLAGS:\n        --r1cs                                 Outputs the constraints in r1cs format\n        --sym                                  Outputs witness in sym format\n        --wasm                                 Compiles the circuit to wasm\n        --json                                 Outputs the constraints in json format\n        --wat                                  Compiles the circuit to wat\n    -c, --c                                    Compiles the circuit to C++\n        --O0                                   No simplification is applied\n        --O1                                   Only applies signal to signal and signal to constant simplification. This\n                                               is the default option\n        --O2                                   Full constraint simplification\n        --verbose                              Shows logs during compilation\n        --inspect                              Does an additional check over the constraints produced\n        --use_old_simplification_heuristics    Applies the old version of the heuristics when performing linear\n                                               simplification\n        --simplification_substitution          Outputs the substitution applied in the simplification phase in json\n                                               format\n        --no_asm                               Does not use asm files in witness generation code in C++\n        --no_init                              Removes initializations to 0 of variables (\"var\") in the witness\n                                               generation code\n    -h, --help                                 Prints help information\n    -V, --version                              Prints version information\n\nOPTIONS:\n    -o, --output &lt;output&gt;                    Path to the directory where the output will be written [default: .]\n    -p, --prime &lt;prime&gt;                      To choose the prime number to use to generate the circuit. Receives the\n                                             name of the curve (bn128, bls12377, bls12381, goldilocks, grumpkin, pallas,\n                                             secq256r1, vesta) [default: bn128]\n    -l &lt;link_libraries&gt;...                   Adds directory to library search path\n        --O2round &lt;simplification_rounds&gt;    Maximum number of rounds of the simplification process\n        --sanity_check &lt;sanity_check&gt;        Selects the level of sanity checks to be included in the witness generation\n                                             code generated. It receives the value 0, 1, or 2. [default: 2]\n\nARGS:\n    &lt;input&gt;    Path to a circuit with a main component [default: ./circuit.circom]\n</code></pre> <p>We created a template called <code>Multiplier2</code> in Writing our first circuit.  However, to actually create a circuit, we have to create an instance of this template. To do so, create a file with the following content:</p> <pre><code>pragma circom 2.0.0;\n\ntemplate Multiplier2() {\n    signal input a;\n    signal input b;\n    signal output c;\n    c &lt;== a*b;\n }\n\n component main = Multiplier2();\n</code></pre> <p>After we write our arithmetic circuit using <code>circom</code>, we should save it in a file with the <code>.circom</code> extension. Remember that you can create your own circuits or use the templates from our library of circuits <code>circomlib</code>.</p> <p>In our example, we create a file called multiplier2.circom. Now is time to compile the circuit to get a system of arithmetic equations representing it. As a result of the compilation we will also obtain programs to compute the witness. We can compile the circuit with the following command:</p> <pre><code>circom multiplier2.circom --r1cs --wasm --sym --c\n</code></pre> <p>With these options we generate three types of files:</p> <ul> <li><code>--r1cs</code>: it generates the file <code>multiplier2.r1cs</code> that contains the R1CS constraint system of the circuit in binary format.</li> <li><code>--wasm</code>: it generates the directory <code>multiplier2_js</code> that contains the <code>Wasm</code> code (multiplier2.wasm) and other files needed to generate the witness.</li> <li><code>--sym</code> : it generates the file <code>multiplier2.sym</code> , a symbols file required for debugging or for printing the constraint system in an annotated mode.</li> <li><code>--c</code> : it generates the directory <code>multiplier2_cpp</code> that contains several files (multiplier2.cpp, multiplier2.dat, and other common files for every compiled program  like main.cpp, MakeFile, etc)  needed to compile the C++ code to generate the witness. By default, this option generates an asm file that is incompatible with some architectures. To avoid producing asm files, the flag <code>--no_asm</code> must be activated.</li> </ul> <p>We can use the option <code>-o</code> to specify the directory where these files are created. </p> <p>Since version 2.0.8, we can use the option <code>-l</code> to indicate the directory where the directive <code>include</code> should look for the circuits indicated.</p>"},{"location":"getting-started/computing-the-witness/","title":"Computing our witness","text":""},{"location":"getting-started/computing-the-witness/#what-is-a-witness","title":"What is a witness?","text":"<p>Before creating the proof, we need to calculate all the signals of the circuit that match all the constraints of the circuit. For that, we will use the <code>Wasm</code> module generated by<code>circom</code> that helps to do this job. It can also be done with the <code>C++</code> code in a similar way (see below).</p> <p>Let us start with the <code>Wasm</code> code. Using the generated <code>Wasm</code> binary and three JavaScript files, we simply need to provide a file with the inputs and the module will execute the circuit and calculate all the intermediate signals and the output. The set of inputs, intermediate signals and output is called witness.</p> <p>In our case, we want to prove that we are able to factor the number 33. So, we assign <code>a = 3</code> and <code>b = 11</code>.</p> <p>Note that we could assign the number 1 to one of the inputs and the number 33 to the other. So, our proof does not really show that we are able to factor the number 33. </p> <p>We need to create a file named <code>input.json</code> containing the inputs written in the standard json format.</p> <p>We use strings instead of numbers because JavaScript does not work accurately with integers larger than 2<sup>53</sup>.</p> <pre><code>{\"a\": \"3\", \"b\": \"11\"}\n</code></pre> <p>Now, we calculate the witness and generate a binary file <code>witness.wtns</code> containing it in a format accepted by <code>snarkjs</code>.</p> <p>After calling the <code>circom</code> compiler with the flag <code>--wasm</code> and the circuit <code>multiplier2.circom</code> we can find a <code>multiplier2_js</code> folder that contains the <code>Wasm</code> code in multiplier2.wasm and all the needed <code>JavaScript</code> files.</p>"},{"location":"getting-started/computing-the-witness/#computing-the-witness-with-webassembly","title":"Computing the witness with WebAssembly","text":"<p>Enter in the directory <code>multiplier2_js</code>, add the input in a file <code>input.json</code> and execute:</p> <pre><code>node generate_witness.js multiplier2.wasm input.json witness.wtns\n</code></pre>"},{"location":"getting-started/computing-the-witness/#computing-the-witness-with-c","title":"Computing the witness with C++","text":"<p>As a faster alternative, we can use the C++ directory to compute the witness using the previous file <code>input.json</code>. This directory is created when using the <code>circom</code> compiler with the flag <code>--c</code>. In our example, the compiler creates a <code>multiplier2_cpp</code> folder that contains all the <code>C++</code> code needed to compute the witness and a Makefile to easily generate the corresponding executable program.</p> <p>To do so, enter the directory <code>multiplier2_cpp</code> and execute:</p> <pre><code>make\n</code></pre> <p>The previous command creates an executable called <code>multiplier2</code>. </p> <p>Note. To compile the C++ source, we rely on some libraries that you need to have installed in your system.  In particular, we use <code>nlohmann-json3-dev</code>, <code>libgmp-dev</code> and <code>nasm</code>.</p> <p>After the executable is created, we execute it indicating the input file and the name for the witness file: </p> <pre><code>./multiplier2 input.json witness.wtns\n</code></pre>"},{"location":"getting-started/computing-the-witness/#the-witness-file","title":"The Witness file","text":"<p>The two programs will generate the same <code>\u1e81itness.wtns</code> file. This file is encoded in a binary format compatible with <code>snarkjs</code>, which is the tool that we use to create the actual proofs. </p> <p>Note. For big circuits, the C++ witness calculator is significantly faster than the WASM calculator.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#installing-the-circom-ecosystem","title":"Installing the circom ecosystem","text":""},{"location":"getting-started/installation/#important-deprecation-note","title":"\u26a0 Important deprecation note","text":"<p>The old <code>circom</code> compiler written in Javascript will be frozen, but it can still be downloaded from the old circom repository.</p>"},{"location":"getting-started/installation/#installing-dependencies","title":"Installing dependencies","text":"<p>You need several dependencies in your system to  run <code>circom</code> and its associated tools.</p> <ul> <li>The core tool is the <code>circom</code> compiler which is written in Rust.    To have Rust available in your system, you can install <code>rustup</code>. If you\u2019re using Linux or macOS, open a terminal and enter the following command:</li> </ul> <pre><code>curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n</code></pre> <ul> <li>We also distribute a series of npm packages so <code>Node.js</code> and some package manager like <code>npm</code> or <code>yarn</code> should be available in your system. Recent versions of <code>Node.js</code> include big integer support and web assembly compilers that help run code faster, so to get a better performance, install version 10 or higher.</li> </ul>"},{"location":"getting-started/installation/#installing-circom","title":"Installing circom","text":"<p>To install from our sources, clone the <code>circom</code> repository: </p> <pre><code>git clone https://github.com/iden3/circom.git\n</code></pre> <p>Enter the circom directory and use the cargo build to compile:</p> <pre><code>cargo build --release\n</code></pre> <p>The installation takes around 3 minutes to be completed. When the command successfully finishes, it generates the <code>circom</code> binary in the directory <code>target/release</code>.  You can install this binary as follows (Note: Make sure you're still in the circom directory when running this command) :</p> <pre><code>cargo install --path circom\n</code></pre> <p>The previous command will install the <code>circom</code> binary in the directory  <code>$HOME/.cargo/bin</code>. </p> <p>Now, you should be able to see all the options of the executable by using the <code>help</code> flag:</p> <pre><code>circom --help\n\nUSAGE:\n    circom [FLAGS] [OPTIONS] [--] [input]\n\nFLAGS:\n        --r1cs                                 Outputs the constraints in r1cs format\n        --sym                                  Outputs witness in sym format\n        --wasm                                 Compiles the circuit to wasm\n        --json                                 Outputs the constraints in json format\n        --wat                                  Compiles the circuit to wat\n    -c, --c                                    Compiles the circuit to C++\n        --O0                                   No simplification is applied\n        --O1                                   Only applies signal to signal and signal to constant simplification. This\n                                               is the default option\n        --O2                                   Full constraint simplification\n        --verbose                              Shows logs during compilation\n        --inspect                              Does an additional check over the constraints produced\n        --use_old_simplification_heuristics    Applies the old version of the heuristics when performing linear\n                                               simplification\n        --simplification_substitution          Outputs the substitution applied in the simplification phase in json\n                                               format\n        --no_asm                               Does not use asm files in witness generation code in C++\n        --no_init                              Removes initializations to 0 of variables (\"var\") in the witness\n                                               generation code\n    -h, --help                                 Prints help information\n    -V, --version                              Prints version information\n\nOPTIONS:\n    -o, --output &lt;output&gt;                    Path to the directory where the output will be written [default: .]\n    -p, --prime &lt;prime&gt;                      To choose the prime number to use to generate the circuit. Receives the\n                                             name of the curve (bn128, bls12377, bls12381, goldilocks, grumpkin, pallas,\n                                             secq256r1, vesta) [default: bn128]\n    -l &lt;link_libraries&gt;...                   Adds directory to library search path\n        --O2round &lt;simplification_rounds&gt;    Maximum number of rounds of the simplification process\n        --sanity_check &lt;sanity_check&gt;        Selects the level of sanity checks to be included in the witness generation\n                                             code generated. It receives the value 0, 1, or 2. [default: 2]\n\nARGS:\n    &lt;input&gt;    Path to a circuit with a main component [default: ./circuit.circom]\n</code></pre>"},{"location":"getting-started/installation/#installing-snarkjs","title":"Installing snarkjs","text":"<p><code>snarkjs</code> is a npm package that contains code to generate and validate ZK proofs from the artifacts produced by <code>circom</code>. </p> <p>You can install <code>snarkjs</code> with the following command:</p> <pre><code>npm install -g snarkjs\n</code></pre>"},{"location":"getting-started/proving-circuits/","title":"Proving circuits","text":"<p>After compiling the circuit and running the witness calculator with  an appropriate input, we will have a file with extension .wtns that  contains all the computed signals and, a file with extension .r1cs that contains the constraints describing the circuit. Both files will be used to create our proof.</p> <p>Now, we will use the <code>snarkjs</code> tool to generate and validate a proof for our input. In particular, using the multiplier2, we will prove that we are able to provide the two factors of the number 33. That is, we will show that we know two integers <code>a</code> and <code>b</code> such that when we multiply them, it results in the number 33.</p> <p>We are going to use the Groth16 zk-SNARK protocol. To use this protocol, you will need to generate a trusted setup. Groth16 requires a per circuit trusted setup. In more detail, the trusted setup consists of 2 parts:</p> <ul> <li>The powers of tau, which is independent of the circuit.</li> <li>The phase 2, which depends on the circuit. </li> </ul> <p>Next, we provide a very basic ceremony for creating the trusted setup and we also provide the basic commands to create and verify Groth16 proofs. Review the related Background section and check the snarkjs tutorial for further information.</p>"},{"location":"getting-started/proving-circuits/#powers-of-tau","title":"Powers of Tau","text":"<p>First, we start a new \"powers of tau\" ceremony:</p> <pre><code>snarkjs powersoftau new bn128 12 pot12_0000.ptau -v\n</code></pre> <p>Then, we contribute to the ceremony:</p> <pre><code>snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\"First contribution\" -v\n</code></pre> <p>Now, we have the contributions to the powers of tau in the file pot12_0001.ptau and  we can proceed with the Phase 2.</p>"},{"location":"getting-started/proving-circuits/#phase-2","title":"Phase 2","text":"<p>The phase 2 is circuit-specific.  Execute the following command to start the generation of this phase:</p> <pre><code>snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v\n</code></pre> <p>Next, we generate a <code>.zkey</code> file that will contain the proving and verification keys together with all phase 2 contributions. Execute the following command to start a new zkey:</p> <pre><code>snarkjs groth16 setup multiplier2.r1cs pot12_final.ptau multiplier2_0000.zkey\n</code></pre> <p>Contribute to the phase 2 of the ceremony:</p> <pre><code>snarkjs zkey contribute multiplier2_0000.zkey multiplier2_0001.zkey --name=\"1st Contributor Name\" -v\n</code></pre> <p>Export the verification key:</p> <pre><code>snarkjs zkey export verificationkey multiplier2_0001.zkey verification_key.json\n</code></pre>"},{"location":"getting-started/proving-circuits/#generating-a-proof","title":"Generating a Proof","text":"<p>Once the witness is computed and the trusted setup is already executed, we can generate a zk-proof associated to the circuit and the witness:</p> <pre><code>snarkjs groth16 prove multiplier2_0001.zkey witness.wtns proof.json public.json\n</code></pre> <p>This command generates a Groth16 proof and outputs two files:</p> <ul> <li><code>proof.json</code>: it contains the proof.</li> <li><code>public.json</code>: it contains the values of the public inputs and outputs.</li> </ul>"},{"location":"getting-started/proving-circuits/#verifying-a-proof","title":"Verifying a Proof","text":"<p>To verify the proof, execute the following command:</p> <pre><code>snarkjs groth16 verify verification_key.json public.json proof.json\n</code></pre> <p>The command uses the files <code>verification_key.json</code> we exported earlier,<code>proof.json</code> and <code>public.json</code> to check if the proof is valid. If the proof is valid, the command outputs an <code>OK</code>.</p> <p>A valid proof not only proves that we know a set of signals that satisfy the circuit, but also that the public inputs and outputs that we use match the ones described in the <code>public.json</code> file.</p>"},{"location":"getting-started/proving-circuits/#verifying-from-a-smart-contract","title":"Verifying from a Smart Contract","text":"<p>\u200b\ud83d\udc49 It is also possible to generate a Solidity verifier that allows verifying proofs on Ethereum blockchain.</p> <p>First, we need to generate the Solidity code using the command:</p> <pre><code>snarkjs zkey export solidityverifier multiplier2_0001.zkey verifier.sol\n</code></pre> <p>This command takes validation key <code>multiplier2_0001.zkey</code> and outputs Solidity code in a file named <code>verifier.sol</code>. You can take the code from this file and cut and paste it in Remix. You will see that the code contains two contracts: <code>Pairing</code> and <code>Verifier</code>. You only need to deploy the <code>Verifier</code> contract.</p> <p>You may want to use first a testnet like Rinkeby, Kovan or Ropsten. You can also use the JavaScript VM, but in some browsers the verification takes long and the page may freeze.</p> <p>The <code>Verifier</code> has a <code>view</code> function called <code>verifyProof</code> that returns <code>TRUE</code> if and only if the proof and the inputs are valid. To facilitate the call, you can use <code>snarkJS</code> to generate the parameters of the call by typing:</p> <pre><code>snarkjs generatecall\n</code></pre> <p>Cut and paste the output of the command to the parameters field of the <code>verifyProof</code> method in Remix. If everything works fine, this method should return <code>TRUE</code>. You can try to change just a single bit of the parameters, and you will see that the result is verifiable <code>FALSE</code>.</p>"},{"location":"getting-started/testing-circuits/","title":"Testing circuits","text":""},{"location":"getting-started/testing-circuits/#writing-a-test","title":"Writing a test","text":""},{"location":"getting-started/testing-circuits/#run-our-tests","title":"Run our tests","text":""},{"location":"getting-started/writing-circuits/","title":"Writing circuits","text":"<p><code>circom</code> allows programmers to define the constraints that define the arithmetic circuit. All constraints must be of the form A*B + C = 0, where A, B and C are linear combinations of signals. More details about these equations can be found here. </p> <p>The arithmetic circuits built using <code>circom</code> operate on signals. Let us define our first circuit that simply multiplies two input signals and produces an output signal.</p> <pre><code>pragma circom 2.0.0;\n\n/*This circuit template checks that c is the multiplication of a and b.*/  \n\ntemplate Multiplier2 () {  \n\n   // Declaration of signals.  \n   signal input a;  \n   signal input b;  \n   signal output c;  \n\n   // Constraints.  \n   c &lt;== a * b;  \n}\n</code></pre> <p>First, the <code>pragma</code> instruction is used to specify the compiler version. This is to ensure that the circuit is compatible with the compiler version indicated after the <code>pragma</code> instruction. Otherwise, the compiler will throw a warning. </p> <p>Then, we use the reserved keyword <code>template</code> to define the shape of a new circuit, called <code>Multiplier2</code>.  Now, we have to define its signals. Signals can be named with an identifier, e.g.,  <code>a, b, c.</code>  In this circuit, we have two input signals<code>a, b</code> and an output signal <code>c</code>.  Finally, we use <code>&lt;==</code> to set that the value of <code>c</code> is the result of multiplying the values of <code>a</code> and <code>b</code>.  Equivalently, we could have also used the operator <code>==&gt;</code>, e.g., <code>a * b ==&gt; c</code>.</p> <p>Let us notice that in each template, we first declare its signals, and after that, the associated constraints.</p>"},{"location":"more-circuits/more-basic-circuits/","title":"More basic circuits","text":""},{"location":"more-circuits/more-basic-circuits/#extending-our-multiplier-to-three-inputs","title":"Extending our multiplier to three inputs","text":"<p>Building on top of the 2-input multiplier, we can build a 3-input multiplier.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate Multiplier2(){\n     /*Code from the previous example.*/\n}\n\n//This circuit multiplies in1, in2, and in3.\ntemplate Multiplier3 () {\n   //Declaration of signals and components.\n   signal input in1;\n   signal input in2;\n   signal input in3;\n   signal output out;\n   component mult1 = Multiplier2();\n   component mult2 = Multiplier2();\n\n   //Statements.\n   mult1.in1 &lt;== in1;\n   mult1.in2 &lt;== in2;\n   mult2.in1 &lt;== mult1.out;\n   mult2.in2 &lt;== in3;\n   out &lt;== mult2.out;\n}\n\ncomponent main = Multiplier3();\n</code></pre> <p>As expected, we first declare three input signals <code>in1, in2, in3,</code> and an output signal <code>out</code> and two instances of <code>Multiplier2</code> . Instantiations of templates are done using the keyword <code>component</code>. We need an instance <code>mult1</code> to multiply <code>in1</code> and <code>in2</code>. In order to assign the values of the input signals of <code>mult1</code> we use the dot notation <code>\".\"</code>. Once <code>mult1.in1</code> and <code>mult1.in2</code> have their values set, then the value of <code>mult1.out</code> is computed. This value can be now used to set the input value of <code>mult2</code>  of the second instance of <code>Multiplier2</code>to multiply <code>in1*in2</code> and <code>in3</code> obtaining the final result  <code>in1*in2*in3</code>.</p> <p>Finally, every execution starts from an initial main component defined as follows.</p> <pre><code>component main {public [in1,in2,in3]} = Multiplier3();\n</code></pre> <p>Here, we indicate that the initial component for our first circom program is the circuit <code>Multiplier3</code> which has three public signals: <code>in1, in2</code> and <code>in3</code>. In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of signals are all private and cannot be made public.</p>"},{"location":"more-circuits/more-basic-circuits/#extending-our-multiplier-to-n-inputs","title":"Extending our multiplier to N inputs","text":"<p>When defining a template, we can use parameters to build generic circuits. These parameters must have a known value at the moment of the instantiation of the template. Following up the previous example, we can implement an N-input multiplier, where <code>N</code> is a parameter.</p> <pre><code>pragma circom 2.0.0; \n\ntemplate Multiplier2(){\n     /*Code from the previous example.*/\n}\n\ntemplate MultiplierN (N){\n   //Declaration of signals and components.\n   signal input in[N];\n   signal output out;\n   component comp[N-1];\n\n   //Statements.\n   for(var i = 0; i &lt; N-1; i++){\n       comp[i] = Multiplier2();\n   }\n\n   // ... some more code (see below)\n\n}\n\ncomponent main = MultiplierN(4);\n</code></pre> <p>In addition to the parameter<code>N</code>, two well-known concepts appear in this fragment of code: arrays and integer variables. </p> <p>As we have seen for a 3-input multiplier, we need 3 input signals and 2 components of <code>Multiplier2</code>. Then, for an N-input multiplier, we need an N-dimensional array of input signals and an \\(N-1\\)-dimensional array of components of <code>Multiplier2</code>. </p> <p>We also need an integer variable <code>i</code> to instantiate each component <code>comp[i]</code>. Once this is done, we have to set the signals for each component as follows:</p> <pre><code>   comp[0].in1 &lt;== in[0];\n   comp[0].in2 &lt;== in[1];\n   for(var i = 0; i &lt; N-2; i++){\n       comp[i+1].in1 &lt;== comp[i].out;\n       comp[i+1].in2 &lt;== in[i+2]; \n   }\n   out &lt;== comp[N-2].out; \n}\n</code></pre> <p>Similarly to <code>Multiplier3</code>, each output signal of a component becomes one of the input signals of the next component. Finally, <code>out</code> is set as the output signal of the last component and its value will be <code>in[0]*in[1]*...*in[N-1]</code>. Finally, we define as main component a <code>MultiplierN</code> with <code>N = 3</code>.</p> <pre><code>component main {public [in]} = MultiplierN(3);\n</code></pre> <pre><code>pragma circom 2.0.0;\n\ntemplate Multiplier2(){\n   //Declaration of signals.\n   signal input in1;\n   signal input in2;\n   signal output out;\n\n   //Statements.\n   out &lt;== in1 * in2;\n}\n\ntemplate Multiplier3 () {\n   //Declaration of signals.\n   signal input in1;\n   signal input in2;\n   signal input in3;\n   signal output out;\n   component mult1 = Multiplier2();\n   component mult2 = Multiplier2();\n\n   //Statements.\n   mult1.in1 &lt;== in1;\n   mult1.in2 &lt;== in2;\n   mult2.in1 &lt;== mult1.out;\n   mult2.in2 &lt;== in3;\n   out &lt;== mult2.out;\n}\n\ntemplate MultiplierN (N){\n   //Declaration of signals.\n   signal input in[N];\n   signal output out;\n   component comp[N-1];\n\n   //Statements.\n   for(var i = 0; i &lt; N-1; i++){\n       comp[i] = Multiplier2();\n   }\n   comp[0].in1 &lt;== in[0];\n   comp[0].in2 &lt;== in[1];\n   for(var i = 0; i &lt; N-2; i++){\n       comp[i+1].in1 &lt;== comp[i].out;\n       comp[i+1].in2 &lt;== in[i+2];\n\n   }\n   out &lt;== comp[N-2].out; \n}\n\ncomponent main {public [in]} = MultiplierN(3);\n</code></pre>"},{"location":"more-circuits/more-basic-circuits/#writing-a-circuit-for-binary-checks","title":"Writing a circuit for binary checks","text":"<p>Let us build a circuit that checks if the input signal is binary. In case it is, the circuit returns an output signal with the same value than<code>in</code>. </p> <pre><code>pragma circom 2.0.0;\n\ntemplate binaryCheck () {\n\n   // Declaration of signals.\n\n   signal input in;\n   signal output out;\n\n   // Statements.\n\n   in * (in-1) === 0;\n   out &lt;== in;\n}\n\ncomponent main = binaryCheck();\n</code></pre> <p>After declaring the signals of the circuit, we use the operator <code>===</code>to introduce the constraint <code>in * (in -1) = 0</code>. The solutions of this constraint are <code>in = 0</code> and <code>in = 1</code>. This means that the constraint has solution if and only if the input signal is binary.</p> <p>The instruction <code>out &lt;== in</code> not only assigns the value of signal <code>in</code> to signal <code>out</code>, but it also adds the constraint <code>out = in</code> to the set of constraints that define the circuit. Then, when both constraints have solution, it is guaranteed that the output signal is binary. Sometimes, we only want to assign the value of a signal but not adding the corresponding constraint. In this case, we will use the operator <code>&lt;--</code> and <code>--&gt;</code>. The differences between <code>&lt;--/--&gt;</code> and <code>&lt;==/==&gt;</code> are described here.</p>"},{"location":"more-circuits/more-basic-circuits/#writing-a-logic-gate-and-with-two-inputs","title":"Writing a logic gate AND with two inputs","text":"<p>We are going to use the circuits <code>Multiplier2</code> and <code>binaryCheck</code> to build a 2-gate logic AND.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate Multiplier2(){\n   //Declaration of signals\n   signal input in1;\n   signal input in2;\n   signal output out;\n\n   //Statements.\n   out &lt;== in1 * in2;\n}\n\ntemplate binaryCheck () {\n   //Declaration of signals.\n   signal input in;\n   signal output out;\n\n   //Statements.\n   in * (in-1) === 0;\n   out &lt;== in;\n}\n\ntemplate And2(){\n   //Declaration of signals and components.\n   signal input in1;\n   signal input in2;\n   signal output out;\n   component mult = Multiplier2();\n   component binCheck[2];\n\n   //Statements.\n   binCheck[0] = binaryCheck();\n   binCheck[0].in &lt;== in1;\n   binCheck[1] = binaryCheck();\n   binCheck[1].in &lt;== in2;\n   mult.in1 &lt;== binCheck[0].out;\n   mult.in2 &lt;== binCheck[1].out;\n   out &lt;== mult.out;\n}\n\ncomponent main = And2();\n</code></pre> <p>Simplifying, the 2-gate AND circuit can be defined by the next constraints:</p> <p><code>in1 * (in1 - 1) = 0</code>, <code>in2 * (in2 - 1) = 0</code>, <code>out = in1 * in2</code></p> <p>These constraints are satisfiable if and only  if <code>in1, in2</code> are binary signals. Consequently, <code>out</code> will also be binary.</p>"},{"location":"more-circuits/more-basic-circuits/#extending-our-and-logic-gate-to-n-inputs","title":"Extending our AND logic gate to N inputs","text":"<p>Finally, let us build an N-gate logic AND using circuit <code>Multiplier2</code> and <code>binaryCheck</code>.</p> <pre><code>pragma circom 2.0.0;\n\ntemplate binaryCheck () {\n   /*Code from previous example*/\n}\n\ntemplate Multiplier2 () {\n   /*Code from previous example*/\n}\n\ntemplate AndN (N){\n   //Declaration of signals and components.\n   signal input in[N];\n   signal output out;\n   component mult[N-1];\n   component binCheck[N];\n\n   //Statements.\n   for(var i = 0; i &lt; N; i++){\n       binCheck[i] = binaryCheck();\n         binCheck[i].in &lt;== in[i];\n   }\n   for(var i = 0; i &lt; N-1; i++){\n       mult[i] = Multiplier2();\n   }\n   mult[0].in1 &lt;== binCheck[0].out;\n   mult[0].in2 &lt;== binCheck[1].out;\n   for(var i = 0; i &lt; N-2; i++){\n       mult[i+1].in1 &lt;== mult[i].out;\n       mult[i+1].in2 &lt;== binCheck[i+2].out;\n\n   }\n   out &lt;== mult[N-2].out; \n}\n\ncomponent main = AndN(4);\n</code></pre> <p>This program is very similar to <code>MultiplierN</code>, but every  signal involved in it is binary.</p> <p>It is important to highlight that we cannot use a (2N-1)-dimensional array to instantiate all the components since, every component of an array must be an instance of the same template with (optionally) different parameters.</p>"}]}